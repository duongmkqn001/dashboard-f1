<!DOCTYPE html>
<html lang="vi" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nh·∫≠p d·ªØ li·ªáu CSV</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./css/dashboard-v2.css">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .animate-slide-in {
            animation: slide-in 0.3s ease-out;
        }
        #theme-switcher .theme-btn.active {
            background-color: var(--bg-button-active);
            color: var(--text-button-active);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="min-h-screen bg-main">
    <!-- Authentication Check -->
    <script>
        window.addEventListener('load', () => {
            const currentUser = localStorage.getItem('currentUser');
            if (!currentUser) {
                window.location.href = 'index.html';
                return;
            }
            
            const user = JSON.parse(currentUser);
            if (user.status !== 'active') {
                alert('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p trang n√†y');
                window.location.href = 'dashboard-v2.html';
                return;
            }
        });
    </script>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Header -->
        <div class="mb-8">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-headings">Nh·∫≠p d·ªØ li·ªáu CSV</h1>
                    <p class="text-secondary mt-2">Nh·∫≠p v√† x·ª≠ l√Ω d·ªØ li·ªáu ticket t·ª´ file CSV</p>
                </div>
                <div class="flex items-center gap-4">
                    <!-- Theme Switcher - Collapsible Button -->
                    <div class="relative">
                        <button id="theme-toggle-btn" class="flex items-center gap-2 bg-section p-2 rounded-lg border border-secondary hover:bg-button transition-colors">
                            <span class="text-sm font-medium">üé®</span>
                            <span id="current-theme-name" class="text-sm font-medium hidden sm:inline">T·ªëi</span>
                            <svg class="w-4 h-4 transition-transform duration-200" id="theme-chevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </button>
                        <div id="theme-dropdown" class="absolute top-full right-0 mt-2 bg-section border border-secondary rounded-lg shadow-lg p-2 hidden z-50 min-w-[200px]">
                            <div class="grid grid-cols-1 gap-1">
                                <button data-theme="dark" class="theme-btn text-left text-sm py-2 px-3 rounded-md hover:bg-button transition-colors">üåô T·ªëi</button>
                                <button data-theme="daylight" class="theme-btn text-left text-sm py-2 px-3 rounded-md hover:bg-button transition-colors">‚òÄÔ∏è Ban ng√†y</button>
                                <button data-theme="sunset" class="theme-btn text-left text-sm py-2 px-3 rounded-md hover:bg-button transition-colors">üåÖ Ho√†ng h√¥n</button>
                                <button data-theme="twilight" class="theme-btn text-left text-sm py-2 px-3 rounded-md hover:bg-button transition-colors">üåÜ Ch·∫°ng v·∫°ng</button>
                                <button data-theme="blossom-dawn" class="theme-btn text-left text-sm py-2 px-3 rounded-md hover:bg-button transition-colors">üå∏ B√¨nh minh</button>
                                <button data-theme="blue-sky" class="theme-btn text-left text-sm py-2 px-3 rounded-md hover:bg-button transition-colors">üå§Ô∏è Tr·ªùi xanh</button>
                                <button data-theme="fresh-mint" class="theme-btn text-left text-sm py-2 px-3 rounded-md hover:bg-button transition-colors">üåø B·∫°c h√†</button>
                            </div>
                        </div>
                    </div>
                    <button onclick="window.location.href='adminview.html'" class="px-4 py-2 bg-button hover:brightness-110 text-main font-semibold rounded-lg">
                        ‚Üê Quay l·∫°i Admin
                    </button>
                    <button onclick="logout()" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg">
                        ƒêƒÉng xu·∫•t
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Panel: Upload & Configuration -->
            <div class="lg:col-span-1">
                <div class="bg-section rounded-lg shadow p-6 border border-main">
                    <h2 class="text-xl font-semibold mb-4 text-headings">1. T·∫£i l√™n file CSV</h2>

                    <!-- File Upload -->
                    <div class="mb-6">
                        <label class="block text-sm font-medium text-secondary mb-2">
                            Ch·ªçn file CSV
                        </label>
                        <input type="file" id="csv-file-input" accept=".csv"
                               class="block w-full text-sm text-main file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-button file:text-main hover:file:brightness-110">
                    </div>

                    <!-- Processing Mode Selection -->
                    <div id="mode-selection" class="mb-6 p-4 bg-yellow-50 dark:bg-yellow-900 rounded-lg border-2 border-yellow-300 hidden">
                        <div class="mb-4">
                            <label class="block text-sm font-medium text-secondary mb-2">
                                ‚öôÔ∏è Ch·ªçn ch·∫ø ƒë·ªô x·ª≠ l√Ω d·ªØ li·ªáu:
                            </label>
                            <select id="processing-mode" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100">
                                <option value="complete-replace">üîÑ Logic 1: X√≥a to√†n b·ªô b·∫£ng v√† nh·∫≠p l·∫°i t·ª´ file</option>
                                <option value="smart-update">üîÑ Logic 2: C·∫≠p nh·∫≠t th√¥ng minh (Re-Open ticket)</option>
                            </select>
                            <div class="mt-2 text-xs text-gray-600 dark:text-gray-400">
                                <div id="mode-description" class="p-2 bg-gray-100 dark:bg-gray-800 rounded">
                                    <strong>Logic 1:</strong> X√≥a to√†n b·ªô b·∫£ng tickets v√† nh·∫≠p l·∫°i t·ª´ file CSV.
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Process Button -->
                    <button id="process-btn" disabled
                            class="w-full py-3 px-4 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:text-gray-200 disabled:hover:bg-gray-400 text-white font-semibold rounded-lg transition-colors">
                        <span id="process-text">X·ª≠ l√Ω CSV</span>
                        <div id="process-spinner" class="loading-spinner ml-2 hidden inline-block"></div>
                    </button>
                </div>

                <!-- Progress Panel -->
                <div id="progress-panel" class="bg-section rounded-lg shadow p-6 mt-6 hidden border border-main">
                    <h3 class="text-lg font-semibold mb-4 text-headings">Ti·∫øn tr√¨nh x·ª≠ l√Ω</h3>
                    <div class="space-y-3">
                        <div class="flex items-center">
                            <div id="step1-icon" class="w-6 h-6 rounded-full bg-gray-500 flex items-center justify-center mr-3">
                                <span class="text-xs text-white">1</span>
                            </div>
                            <span id="step1-text" class="text-secondary">ƒê·ªçc file CSV</span>
                        </div>
                        <div class="flex items-center">
                            <div id="step2-icon" class="w-6 h-6 rounded-full bg-gray-500 flex items-center justify-center mr-3">
                                <span class="text-xs text-white">2</span>
                            </div>
                            <span id="step2-text" class="text-secondary">X·ª≠ l√Ω d·ªØ li·ªáu</span>
                        </div>
                        <div class="flex items-center">
                            <div id="step3-icon" class="w-6 h-6 rounded-full bg-gray-500 flex items-center justify-center mr-3">
                                <span class="text-xs text-white">3</span>
                            </div>
                            <span id="step3-text" class="text-secondary">Chu·∫©n b·ªã nh·∫≠p d·ªØ li·ªáu</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Results & Preview -->
            <div class="lg:col-span-2">
                <div class="bg-section rounded-lg shadow p-6 border border-main">
                    <h2 class="text-xl font-semibold mb-4 text-headings">K·∫øt qu·∫£ x·ª≠ l√Ω</h2>

                    <!-- Status Messages - Hidden, using toast notifications instead -->
                    <div id="status-messages" class="hidden"></div>

                    <!-- Toast Notification Container -->
                    <div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2 max-w-sm"></div>

                    <!-- Data Preview -->
                    <div id="data-preview" class="hidden">
                        <!-- Import Actions -->
                        <div class="mb-6 p-4 bg-green-50 dark:bg-green-900 rounded-lg border-2 border-green-300">
                            <div class="mb-4">
                                <p id="selected-mode-info" class="text-sm font-medium text-green-800 dark:text-green-200 mb-2">
                                    Ch·∫ø ƒë·ªô ƒë√£ ch·ªçn: <span id="current-mode-name">Ch·ªâ nh·∫≠p m·ªõi</span>
                                </p>
                                <p class="text-xs text-gray-600 dark:text-gray-400">
                                    <strong>Ticket ƒë∆∞·ª£c b·∫£o v·ªá (kh√¥ng c·∫≠p nh·∫≠t):</strong> ƒê√£ start, ƒë√£ end, c√≥ needMos, c√≥ ticket_status_id, need_leader_support = true, ho·∫∑c ƒë√£ ƒë∆∞·ª£c handle
                                </p>
                            </div>
                            <div class="flex gap-4">
                                <button id="import-btn" class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-lg" disabled>
                                    üì• Nh·∫≠p v√†o Database
                                </button>
                                <button id="download-btn" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-lg">
                                    üíæ T·∫£i xu·ªëng CSV ƒë√£ x·ª≠ l√Ω
                                </button>
                            </div>
                        </div>

                        <h3 class="text-lg font-medium mb-3 text-headings">Xem tr∆∞·ªõc d·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω</h3>
                        <div class="overflow-x-auto border border-main rounded-lg">
                            <table id="preview-table" class="min-w-full divide-y divide-main">
                                <thead class="bg-header-footer">
                                    <tr id="preview-header"></tr>
                                </thead>
                                <tbody id="preview-body" class="bg-section divide-y divide-main"></tbody>
                            </table>
                        </div>

                        <!-- Automatic Duplicate Detection Status -->
                        <div id="duplicate-status" class="mt-6 hidden">
                            <div id="duplicate-info" class="p-4 rounded-lg border"></div>
                        </div>
                    </div>

                    <!-- Initial State -->
                    <div id="initial-state" class="text-center py-12">
                        <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                        <h3 class="mt-2 text-sm font-medium text-headings">Ch∆∞a ch·ªçn file</h3>
                        <p class="mt-1 text-sm text-secondary">T·∫£i l√™n file CSV ƒë·ªÉ b·∫Øt ƒë·∫ßu x·ª≠ l√Ω</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://pfbxtbydrjcmqlrklsdr.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBmYnh0YnlkcmpjbXFscmtsc2RyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY5ODM2NDksImV4cCI6MjA3MjU1OTY0OX0.bOgnown0UZzstbnYfUSEImwaSGP6lg2FccRg-yDFTPU';

        let supabaseClient;
        let processedData = [];
        let selectedImportStrategy = 'complete-replace';
        
        try {
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            console.log('Supabase client initialized successfully');
        } catch (error) {
            console.error('Error initializing Supabase:', error);
            alert('Could not initialize Supabase client. Check console for details.');
        }

        // Test Supabase connection
        async function testSupabaseConnection() {
            try {
                const { data, error } = await supabaseClient
                    .from('agent')
                    .select('count')
                    .limit(1);

                if (error) {
                    console.error('Supabase connection test failed:', error);
                    showStatus('‚ö†Ô∏è Database connection issue. Please check authentication.', 'error');
                    return false;
                }
                console.log('Supabase connection test successful');
                return true;
            } catch (error) {
                console.error('Supabase connection test error:', error);
                showStatus('‚ö†Ô∏è Database connection error.', 'error');
                return false;
            }
        }

        // DOM elements
        const csvFileInput = document.getElementById('csv-file-input');
        const processBtn = document.getElementById('process-btn');
        const processText = document.getElementById('process-text');
        const processSpinner = document.getElementById('process-spinner');
        const progressPanel = document.getElementById('progress-panel');
        const statusMessages = document.getElementById('status-messages');
        const dataPreview = document.getElementById('data-preview');
        const initialState = document.getElementById('initial-state');
        const previewTable = document.getElementById('preview-table');
        const previewHeader = document.getElementById('preview-header');
        const previewBody = document.getElementById('preview-body');
        const importBtn = document.getElementById('import-btn');
        const downloadBtn = document.getElementById('download-btn');
        const duplicateStatus = document.getElementById('duplicate-status');
        const duplicateInfo = document.getElementById('duplicate-info');
        const modeSelection = document.getElementById('mode-selection');
        const processingMode = document.getElementById('processing-mode');
        const modeDescription = document.getElementById('mode-description');
        const currentModeName = document.getElementById('current-mode-name');

        // Event listeners
        if (csvFileInput) csvFileInput.addEventListener('change', handleFileSelect);
        if (processBtn) processBtn.addEventListener('click', processCSV);
        if (importBtn) importBtn.addEventListener('click', importToDatabase);
        if (downloadBtn) downloadBtn.addEventListener('click', downloadProcessedCSV);
        if (processingMode) processingMode.addEventListener('change', updateModeDescription);

        // Test database connection on page load
        window.addEventListener('load', async () => {
            await testSupabaseConnection();
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            updateProcessButton();

            if (file) {
                showStatus(`Selected file: ${file.name}`, 'info');
                // Show mode selection when file is selected
                if (modeSelection) {
                    modeSelection.classList.remove('hidden');
                }
            } else {
                // Hide mode selection when no file
                if (modeSelection) {
                    modeSelection.classList.add('hidden');
                }
            }
        }

        // Mode description updater
        function updateModeDescription() {
            if (!modeDescription || !processingMode) return;

            const mode = processingMode.value;
            const descriptions = {
                'complete-replace': '<strong>Logic 1 - X√≥a to√†n b·ªô b·∫£ng:</strong> X√≥a ho√†n to√†n t·∫•t c·∫£ d·ªØ li·ªáu trong b·∫£ng tickets (gi·ªØ l·∫°i c·∫•u tr√∫c b·∫£ng), sau ƒë√≥ nh·∫≠p to√†n b·ªô d·ªØ li·ªáu t·ª´ file CSV. ‚ö†Ô∏è <span class="text-red-600">C·∫©n th·∫≠n - s·∫Ω m·∫•t T·∫§T C·∫¢ d·ªØ li·ªáu hi·ªán t·∫°i!</span>',
                'smart-update': '<strong>Logic 2 - C·∫≠p nh·∫≠t th√¥ng minh:</strong> So s√°nh file v·ªõi database v√† x·ª≠ l√Ω t·ª´ng tr∆∞·ªùng h·ª£p. <span class="text-blue-600">üÜï Th√™m m·ªõi:</span> Ticket ch∆∞a c√≥ trong DB. <span class="text-orange-600">‚úèÔ∏è C·∫≠p nh·∫≠t:</span> Ticket ƒë√£ c√≥ nh∆∞ng ch∆∞a ƒë∆∞·ª£c x·ª≠ l√Ω (agent ch∆∞a b·∫Øt ƒë·∫ßu) ‚Üí c·∫≠p nh·∫≠t th√¥ng tin (v√≠ d·ª•: ƒë·ªïi agent). <span class="text-red-600">üîÑ Re-Open:</span> Ticket ƒë√£ ho√†n th√†nh b·ªüi agent nh∆∞ng v·∫´n c√≤n trong file CSV ‚Üí t·∫°o h√†ng m·ªõi v√† ƒë√°nh d·∫•u <em>Re-Open</em> ƒë·ªÉ d·ªÖ nh·∫≠n bi·∫øt tr√™n Dashboard. <span class="text-gray-600">‚úã Gi·ªØ nguy√™n:</span> Ticket ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω (ƒë√£ b·∫Øt ƒë·∫ßu, c√≥ status...) ‚Üí kh√¥ng thay ƒë·ªïi. <span class="text-red-600">üóëÔ∏è X√≥a:</span> Ticket ch∆∞a x·ª≠ l√Ω c√≥ trong DB nh∆∞ng kh√¥ng c√≥ trong file.'
            };

            const modeNames = {
                'complete-replace': 'Logic 1: X√≥a to√†n b·ªô b·∫£ng',
                'smart-update': 'Logic 2: C·∫≠p nh·∫≠t th√¥ng minh (Re-Open)'
            };

            modeDescription.innerHTML = descriptions[mode] || descriptions['complete-replace'];

            // Update current mode name in preview
            if (currentModeName) {
                currentModeName.textContent = modeNames[mode] || modeNames['complete-replace'];
            }
        }

        function updateProcessButton() {
            if (!csvFileInput || !processBtn) return;
            const hasFile = csvFileInput.files.length > 0;
            processBtn.disabled = !hasFile;
        }

        function logout() {
            localStorage.removeItem('currentUser');
            window.location.href = 'index.html';
        }

        // Toast notification functions
        function showStatus(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            if (!toastContainer) return;

            const toast = document.createElement('div');
            toast.className = `p-4 rounded-lg shadow-lg text-sm transform transition-all duration-300 ${getToastClasses(type)} animate-slide-in`;

            const icon = getToastIcon(type);
            toast.innerHTML = `
                <div class="flex items-center gap-3">
                    <span class="text-xl">${icon}</span>
                    <span class="flex-1">${message}</span>
                    <button onclick="this.parentElement.parentElement.remove()" class="text-gray-500 hover:text-gray-700 font-bold">‚úï</button>
                </div>
            `;

            toastContainer.appendChild(toast);

            // Auto-dismiss: success stays 6 s, info stays 5 s, errors stay 8 s
            const dismissTime = type === 'error' ? 8000 : type === 'success' ? 6000 : 5000;
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => toast.remove(), 300);
            }, dismissTime);
        }

        function getToastClasses(type) {
            switch (type) {
                case 'success': return 'bg-green-500 text-white';
                case 'error': return 'bg-red-500 text-white';
                case 'warning': return 'bg-yellow-500 text-white';
                default: return 'bg-blue-500 text-white';
            }
        }

        function getToastIcon(type) {
            switch (type) {
                case 'success': return '‚úÖ';
                case 'error': return '‚ùå';
                case 'warning': return '‚ö†Ô∏è';
                default: return '‚ÑπÔ∏è';
            }
        }

        function clearStatus() {
            const toastContainer = document.getElementById('toast-container');
            if (toastContainer) toastContainer.innerHTML = '';
        }

        // Main processing function
        async function processCSV() {
            if (!csvFileInput.files[0]) {
                showStatus('Please select a file', 'error');
                return;
            }

            setProcessing(true);
            clearStatus();
            showProgressPanel();

            try {
                // Step 1: Parse CSV
                updateStep(1, 'processing', 'ƒêang ƒë·ªçc file CSV...');
                const csvData = await parseCSVFile(csvFileInput.files[0]);
                if (csvData.length === 0) {
                    throw new Error("File CSV tr·ªëng ho·∫∑c kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng file.");
                }
                updateStep(1, 'complete', 'ƒê·ªçc CSV th√†nh c√¥ng');
                showStatus(`ƒê√£ ƒë·ªçc ${csvData.length} d√≤ng t·ª´ CSV`, 'success');

                // Step 2: Process data (Basic only - AI removed)
                updateStep(2, 'processing', 'ƒêang x·ª≠ l√Ω d·ªØ li·ªáu...');
                const processedRows = await processBasic(csvData);
                updateStep(2, 'complete', 'X·ª≠ l√Ω d·ªØ li·ªáu ho√†n t·∫•t');
                showStatus(`ƒê√£ x·ª≠ l√Ω ${processedRows.length} d√≤ng`, 'success');

                // Step 3: Prepare for import based on selected mode
                updateStep(3, 'processing', 'ƒêang chu·∫©n b·ªã d·ªØ li·ªáu theo ch·∫ø ƒë·ªô ƒë√£ ch·ªçn...');
                const preparedData = await prepareForImport(processedRows);

                // Get selected processing mode
                const selectedMode = processingMode ? processingMode.value : 'add-new-only';

                // Process data based on selected mode
                const { finalData, duplicateCount, totalCount, modeInfo, importStrategy } = await processDataByMode(preparedData, selectedMode);
                processedData = finalData;
                selectedImportStrategy = importStrategy || 'add-new-only';

                updateStep(3, 'complete', 'Chu·∫©n b·ªã d·ªØ li·ªáu ho√†n t·∫•t');
                showStatus(`ƒê√£ chu·∫©n b·ªã ${processedData.length} d√≤ng ƒë·ªÉ nh·∫≠p (${modeInfo})`, 'success');

                // Show duplicate status and preview
                showDuplicateStatus(duplicateCount, totalCount, selectedMode);
                showDataPreview(processedData);
                if (importBtn) importBtn.disabled = false;

            } catch (error) {
                console.error('Processing error:', error);
                showStatus(`L·ªói: ${error.message}`, 'error');
                updateStep(getCurrentStep(), 'error', 'X·ª≠ l√Ω th·∫•t b·∫°i');
            } finally {
                setProcessing(false);
            }
        }

        // Process data based on selected mode
        async function processDataByMode(data, mode) {
            if (!supabaseClient) {
                console.warn('Supabase client not initialized, using all data');
                return {
                    finalData: data,
                    duplicateCount: 0,
                    totalCount: data.length,
                    modeInfo: 'Kh√¥ng th·ªÉ k·∫øt n·ªëi database'
                };
            }

            try {
                // Use ticket numbers as unique identifiers, not issue_id
                const ticketNumbers = data.map(row => row.ticket).filter(t => t);
                if (ticketNumbers.length === 0) {
                    return {
                        finalData: data,
                        duplicateCount: 0,
                        totalCount: data.length,
                        modeInfo: 'Kh√¥ng c√≥ ticket number ƒë·ªÉ ki·ªÉm tra'
                    };
                }

                // Check for existing tickets in database by ticket number
                const { data: existingTickets, error } = await supabaseClient
                    .from('tickets')
                    .select('ticket')
                    .in('ticket', ticketNumbers);

                if (error) {
                    console.error('Error checking for duplicates:', error);
                    showStatus('‚ö†Ô∏è Kh√¥ng th·ªÉ ki·ªÉm tra tr√πng l·∫∑p, ti·∫øp t·ª•c v·ªõi t·∫•t c·∫£ d·ªØ li·ªáu', 'warning');
                    return {
                        finalData: data,
                        duplicateCount: 0,
                        totalCount: data.length,
                        modeInfo: 'L·ªói ki·ªÉm tra database'
                    };
                }

                const existingTicketNumbers = new Set(existingTickets.map(t => String(t.ticket)));

                // Process based on the two logics
                switch (mode) {
                    case 'complete-replace': {
                        // Logic 1: Delete entire table and import from file
                        const completeReplaceData = data.map(row => ({
                            ...row,
                            _isDuplicate: existingTicketNumbers.has(String(row.ticket))
                        }));
                        return {
                            finalData: completeReplaceData,
                            duplicateCount: 0,
                            totalCount: data.length,
                            modeInfo: 'x√≥a to√†n b·ªô b·∫£ng v√† nh·∫≠p l·∫°i',
                            importStrategy: 'complete-replace'
                        };
                    }

                    case 'smart-update': {
                        // Logic 2: Smart update with Re-Open detection
                        // Fetch active (open) tickets and completed tickets separately
                        const [activeResult, completedResult] = await Promise.all([
                            supabaseClient
                                .from('tickets')
                                .select('ticket, time_start, needMos, ticket_status_id, need_leader_support, agent_handle_ticket')
                                .in('ticket', ticketNumbers)
                                .is('time_end', null),
                            supabaseClient
                                .from('tickets')
                                .select('ticket')
                                .in('ticket', ticketNumbers)
                                .not('time_end', 'is', null)
                        ]);

                        if (activeResult.error) throw activeResult.error;
                        if (completedResult.error) throw completedResult.error;

                        const activeMap = new Map((activeResult.data || []).map(t => [String(t.ticket), t]));
                        const completedSet = new Set((completedResult.data || []).map(t => String(t.ticket)));

                        let newCount = 0, updateCount = 0, reopenCount = 0, skipCount = 0;

                        const smartUpdateData = data.map(row => {
                            const ticketNum = String(row.ticket);
                            const activeExisting = activeMap.get(ticketNum);
                            const hasCompleted = completedSet.has(ticketNum);

                            if (!activeExisting && !hasCompleted) {
                                newCount++;
                                return { ...row, _isDuplicate: false, _status: 'üÜï M·ªõi' };
                            } else if (!activeExisting && hasCompleted) {
                                reopenCount++;
                                return { ...row, _isDuplicate: true, _isReopen: true, _status: 'üîÑ Re-Open' };
                            } else if (activeExisting) {
                                const isTouched =
                                    activeExisting.needMos != null ||
                                    activeExisting.ticket_status_id != null ||
                                    activeExisting.need_leader_support === true ||
                                    activeExisting.time_start != null ||
                                    activeExisting.agent_handle_ticket != null;

                                if (isTouched) {
                                    skipCount++;
                                    return { ...row, _isDuplicate: true, _status: '‚úã Gi·ªØ nguy√™n (ƒëang x·ª≠ l√Ω)' };
                                } else {
                                    updateCount++;
                                    return { ...row, _isDuplicate: false, _status: '‚úèÔ∏è C·∫≠p nh·∫≠t' };
                                }
                            }
                            newCount++;
                            return { ...row, _isDuplicate: false, _status: 'üÜï M·ªõi' };
                        });

                        return {
                            finalData: smartUpdateData,
                            duplicateCount: reopenCount,
                            totalCount: data.length,
                            modeInfo: `c·∫≠p nh·∫≠t th√¥ng minh: ${newCount} m·ªõi, ${updateCount} c·∫≠p nh·∫≠t, ${reopenCount} Re-Open, ${skipCount} gi·ªØ nguy√™n`,
                            importStrategy: 'smart-update'
                        };
                    }

                    default: {
                        // Default to complete-replace
                        const defaultData = data.map(row => ({
                            ...row,
                            _isDuplicate: existingTicketNumbers.has(String(row.ticket))
                        }));
                        return {
                            finalData: defaultData,
                            duplicateCount: 0,
                            totalCount: data.length,
                            modeInfo: 'x√≥a to√†n b·ªô b·∫£ng v√† nh·∫≠p l·∫°i (m·∫∑c ƒë·ªãnh)',
                            importStrategy: 'complete-replace'
                        };
                    }
                }

            } catch (error) {
                console.error('Error in processDataByMode:', error);
                showStatus('‚ö†Ô∏è L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu, ti·∫øp t·ª•c v·ªõi t·∫•t c·∫£ d·ªØ li·ªáu', 'warning');
                return {
                    finalData: data,
                    duplicateCount: 0,
                    totalCount: data.length,
                    modeInfo: 'l·ªói x·ª≠ l√Ω'
                };
            }
        }

        // Show duplicate status function
        function showDuplicateStatus(duplicateCount, totalCount, mode = 'complete-replace') {
            if (!duplicateStatus || !duplicateInfo) return;

            const modeMessages = {
                'complete-replace': {
                    noDuplicates: 'T·∫•t c·∫£ d·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c nh·∫≠p. B·∫£ng tickets s·∫Ω b·ªã x√≥a ho√†n to√†n tr∆∞·ªõc khi nh·∫≠p.',
                    hasDuplicates: `T·∫•t c·∫£ ${totalCount} b·∫£n ghi s·∫Ω ƒë∆∞·ª£c nh·∫≠p. B·∫£ng tickets s·∫Ω b·ªã x√≥a ho√†n to√†n tr∆∞·ªõc khi nh·∫≠p. ‚ö†Ô∏è C·∫©n th·∫≠n!`
                },
                'smart-update': {
                    noDuplicates: 'Kh√¥ng c√≥ ticket Re-Open. T·∫•t c·∫£ b·∫£n ghi ƒë·ªÅu l√† m·ªõi ho·∫∑c c·∫≠p nh·∫≠t b√¨nh th∆∞·ªùng.',
                    hasDuplicates: `Ph√°t hi·ªán ${duplicateCount} ticket üîÑ Re-Open (ƒë√£ ho√†n th√†nh nh∆∞ng xu·∫•t hi·ªán l·∫°i trong file CSV). C√°c ticket n√†y s·∫Ω ƒë∆∞·ª£c t·∫°o h√†ng m·ªõi v√† ƒë√°nh d·∫•u Re-Open tr√™n Dashboard ƒë·ªÉ agent d·ªÖ nh·∫≠n bi·∫øt.`
                }
            };

            const messages = modeMessages[mode] || modeMessages['complete-replace'];

            if (duplicateCount === 0) {
                duplicateInfo.className = 'p-4 rounded-lg border bg-green-50 border-green-200';
                duplicateInfo.innerHTML = `
                    <div class="flex items-center">
                        <svg class="w-5 h-5 text-green-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                        <span class="text-green-800 font-medium">‚úÖ Kh√¥ng c√≥ ticket Re-Open</span>
                    </div>
                    <p class="text-green-700 text-sm mt-1">${messages.noDuplicates}</p>
                `;
            } else {
                const colorClass = mode === 'smart-update' ? 'orange' : 'blue';
                duplicateInfo.className = `p-4 rounded-lg border bg-${colorClass}-50 border-${colorClass}-200`;
                duplicateInfo.innerHTML = `
                    <div class="flex items-center">
                        <svg class="w-5 h-5 text-${colorClass}-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <span class="text-${colorClass}-800 font-medium">üîÑ ${mode === 'smart-update' ? 'Ph√°t hi·ªán ticket Re-Open' : 'Th√¥ng tin d·ªØ li·ªáu'}</span>
                    </div>
                    <p class="text-${colorClass}-700 text-sm mt-1">${messages.hasDuplicates}</p>
                `;
            }

            duplicateStatus.classList.remove('hidden');
        }

        // CSV parsing function
        function parseCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const text = event.target.result;
                        const rows = parseRobustCSV(text);
                        
                        if (rows.length < 2) {
                            return reject(new Error('CSV must have a header and at least one data row.'));
                        }

                        const headers = rows[0];
                        const data = rows.slice(1).map(values => {
                            if (values.length === headers.length) {
                                const row = {};
                                headers.forEach((header, index) => {
                                    row[header] = values[index];
                                });
                                return row;
                            } else {
                                console.warn(`Skipping malformed row. Expected ${headers.length} columns, but got ${values.length}.`, values);
                                showStatus(`Warning: Skipping malformed row. Check console for details.`, 'warning');
                                return null;
                            }
                        }).filter(Boolean); // Filter out null rows

                        resolve(data);
                    } catch (e) {
                        reject(e);
                    }
                };
                reader.onerror = (error) => reject(error);
                reader.readAsText(file);
            });
        }

        /**
         * A robust CSV parser that handles quoted fields, newlines within fields, and escaped quotes.
         * @param {string} text The full CSV text.
         * @returns {string[][]} An array of arrays, where each inner array represents a row.
         */
        function parseRobustCSV(text) {
            const rows = [];
            let currentRow = [];
            let currentField = '';
            let inQuotedField = false;

            text = text.replace(/\r\n/g, '\n'); // Normalize line endings

            for (let i = 0; i < text.length; i++) {
                const char = text[i];

                if (inQuotedField) {
                    if (char === '"') {
                        // Check for escaped quote
                        if (i < text.length - 1 && text[i + 1] === '"') {
                            currentField += '"';
                            i++; // Skip next quote
                        } else {
                            inQuotedField = false;
                        }
                    } else {
                        currentField += char;
                    }
                } else {
                    switch (char) {
                        case ',':
                            currentRow.push(currentField);
                            currentField = '';
                            break;
                        case '\n':
                            currentRow.push(currentField);
                            rows.push(currentRow);
                            currentRow = [];
                            currentField = '';
                            break;
                        case '"':
                            if (currentField.length === 0) {
                                inQuotedField = true;
                            } else {
                                currentField += char; // Treat as part of an unquoted field
                            }
                            break;
                        default:
                            currentField += char;
                    }
                }
            }

            // Add the last field and row if the file doesn't end with a newline
            if (currentField.length > 0 || currentRow.length > 0) {
                currentRow.push(currentField);
                rows.push(currentRow);
            }

            return rows;
        }

        // This function is no longer needed for the robust parser.
        function parseCSVLine(line) {
            return;
        }

        // AI processing function removed - no longer needed

        // Basic processing function (without AI)
        async function processBasic(csvData) {
            const processedRows = [];

            for (const row of csvData) {
                const description = row['Description'] || '';

                // For basic processing, fill description directly into description_eng
                const processedRow = {
                    ...row,
                    description_eng: description, // Fill description directly into description_eng
                    description_vie: '', // Leave Vietnamese field empty for basic processing
                    supplier_agent_need: false,
                    supplier_agent: '',
                    ticket: row['Issue key'] || '',
                    po: row['Custom field (PO Number(s))'] || '',
                    suid: extractSUID(row['Custom field (Supplier)'] || ''),
                    su_name: extractSupplierName(row['Custom field (Supplier)'] || ''),
                    order_number: row['Custom field (Order ID(s))'] || '',
                    po_nocs: extractPODigits(row['Custom field (PO Number(s))'] || ''),
                    customer: extractCustomerName(row['Custom field (Customer Name)'] || ''),
                    customer_contact: row['Custom field (Customer Contact(s))'] || '',
                    issue_id: row['Issue id'] || '',
                    agent_account: row['Assignee'] || '',
                    assignee_account: row['Assignee'] || '', // Add assignee_account field
                    issue_type: row['Customer Request Type'] || ''
                };

                processedRows.push(processedRow);
            }

            return processedRows;
        }

        // AI processing functions removed - no longer needed

        // Helper functions for data extraction
        function extractSUID(supplierField) {
            const match = supplierField.match(/^(\d+)/);
            return match ? match[1] : '';
        }

        function extractSupplierName(supplierField) {
            const parts = supplierField.split(' - ');
            return parts.length > 1 ? parts[1] : '';
        }

        function extractPODigits(poField) {
            const match = poField.match(/(?:CS|CA|IE|UK|DE|EU)\s*(\d{9})/i);
            return match ? match[1] : '';
        }

        function extractCustomerName(customerField) {
            if (!customerField) return '';
            return customerField.split(',')[0].trim();
        }

        async function getAgentSTT(assigneeAccount) {
            if (!supabaseClient || !assigneeAccount) return '';
            try {
                const { data, error } = await supabaseClient
                    .from('agent')
                    .select('stt')
                    .eq('agent_account', assigneeAccount)
                    .maybeSingle();

                if (error) {
                    if (error.code === 'PGRST301' || error.message.includes('401')) {
                        console.warn('Authentication issue accessing agent table:', error);
                        showStatus('‚ö†Ô∏è Authentication issue. Please check database permissions.', 'warning');
                    } else {
                        throw error;
                    }
                    return '';
                }
                return data ? data.stt : '';
            } catch (error) {
                console.error('Error fetching agent STT:', error);
                showStatus('‚ö†Ô∏è Error fetching agent data. Using default values.', 'warning');
                return '';
            }
        }

        async function getIssueType(assigneeAccount, customerRequestType) {
            if (!supabaseClient || !assigneeAccount || !customerRequestType) return '';
            try {
                const { data: agentData, error: agentError } = await supabaseClient
                    .from('agent')
                    .select('team')
                    .eq('agent_account', assigneeAccount)
                    .maybeSingle();

                if (agentError) {
                    if (agentError.code === 'PGRST301' || agentError.message.includes('401')) {
                        console.warn('Authentication issue accessing agent table:', agentError);
                        showStatus('‚ö†Ô∏è Authentication issue. Please check database permissions.', 'warning');
                    } else {
                        throw agentError;
                    }
                    return '';
                }
                if (!agentData) return '';

                let taskName = customerRequestType;
                if (customerRequestType === 'Update Tracking Number') {
                    taskName = 'Update tracking number/Order Status';
                } else if (customerRequestType === 'Email Request') {
                    taskName = 'Carrier Inquiry';
                }

                const { data: kpiData, error: kpiError } = await supabaseClient
                    .from('kpi_per_task')
                    .select('id')
                    .eq('team', agentData.team)
                    .eq('task_name', taskName)
                    .limit(1) // Ensure we only get one result
                    .maybeSingle();

                if (kpiError) {
                    if (kpiError.code === 'PGRST301' || kpiError.message.includes('401')) {
                        console.warn('Authentication issue accessing kpi_per_task table:', kpiError);
                        showStatus('‚ö†Ô∏è Authentication issue. Please check database permissions.', 'warning');
                    } else {
                        throw kpiError;
                    }
                    return '';
                }
                return kpiData ? kpiData.id : '';
            } catch (error) {
                console.error('Error fetching issue type:', error);
                showStatus('‚ö†Ô∏è Error fetching issue type data. Using default values.', 'warning');
                return '';
            }
        }

        // Data preparation and UI functions
        async function prepareForImport(processedRows) {
            return processedRows.map(row => ({
                ticket: row.ticket,
                po: row.po,
                suid: row.suid,
                su_name: row.su_name,
                supplier_agent_need: row.supplier_agent_need,
                supplier_agent: row.supplier_agent,
                order_number: row.order_number,
                po_nocs: row.po_nocs,
                customer: row.customer,
                customer_contact: row.customer_contact,
                agent_account: row.agent_account,
                issue_type: row.issue_type,
                issue_id: row.issue_id,
                description_eng: row.description_eng,
                description_vie: row.description_vie
            }));
        }

        function showDataPreview(data) {
            if (!dataPreview || !initialState || !previewHeader || !previewBody) return;
            if (data.length === 0) {
                showStatus('No data to preview', 'warning');
                initialState.classList.remove('hidden');
                dataPreview.classList.add('hidden');
                return;
            }

            initialState.classList.add('hidden');
            dataPreview.classList.remove('hidden');

            const headers = Object.keys(data[0]);
            // Filter out description columns and internal flags to save space
            const visibleHeaders = headers.filter(h =>
                h !== 'description_eng' &&
                h !== 'description_vie' &&
                !h.startsWith('_')
            );

            // Add status column if we have duplicate info
            const hasStatusInfo = data.some(row => row._status || row._isDuplicate !== undefined);
            if (hasStatusInfo) {
                visibleHeaders.unshift('Tr·∫°ng th√°i');
            }

            previewHeader.innerHTML = visibleHeaders.map(header =>
                `<th class="px-3 py-2 text-left text-xs font-medium text-secondary uppercase tracking-wider">${header}</th>`
            ).join('');

            const previewRows = data.slice(0, 10);
            previewBody.innerHTML = previewRows.map(row => {
                const rowClass = row._isReopen ? 'bg-red-50 dark:bg-red-900' : (row._isDuplicate ? 'bg-yellow-50 dark:bg-yellow-900' : '');
                return `<tr class="hover:bg-gray-50 dark:hover:bg-gray-700 ${rowClass}">${visibleHeaders.map(header => {
                    let cellContent = '';
                    let cellClass = `px-3 py-2 text-xs text-main whitespace-nowrap`;

                    if (header === 'Tr·∫°ng th√°i') {
                        if (row._status) {
                            cellContent = row._status;
                            cellClass += row._isReopen ? ' text-red-600 font-bold' : (row._isDuplicate ? ' text-orange-600 font-medium' : ' text-green-600 font-medium');
                        } else if (row._isDuplicate !== undefined) {
                            cellContent = row._isReopen ? 'üîÑ Re-Open' : (row._isDuplicate ? 'Tr√πng l·∫∑p' : 'M·ªõi');
                            cellClass += row._isReopen ? ' text-red-600 font-bold' : (row._isDuplicate ? ' text-orange-600 font-medium' : ' text-green-600 font-medium');
                        }
                    } else {
                        cellContent = row[header] || '';
                    }

                    return `<td class="${cellClass}">${cellContent}</td>`;
                }).join('')}</tr>`;
            }).join('');

            if (data.length > 10) {
                showStatus(`Showing first 10 rows of ${data.length} total rows`, 'info');
            }
        }

        async function importToDatabase() {
            if (!supabaseClient) {
                showStatus('Supabase client not initialized.', 'error');
                return;
            }
            if (processedData.length === 0) {
                showStatus('No data to import', 'error');
                return;
            }

            const strategy = selectedImportStrategy;
            const strategyNames = {
                'complete-replace': 'Logic 1: X√≥a to√†n b·ªô b·∫£ng v√† nh·∫≠p l·∫°i t·ª´ file',
                'smart-update': 'Logic 2: C·∫≠p nh·∫≠t th√¥ng minh (Re-Open ticket)'
            };

            if (!confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën nh·∫≠p ${processedData.length} b·∫£n ghi b·∫±ng chi·∫øn l∆∞·ª£c: ${strategyNames[strategy] || strategy}?`)) {
                return;
            }

            try {
                showStatus(`ƒêang nh·∫≠p d·ªØ li·ªáu b·∫±ng ${strategyNames[strategy] || strategy}...`, 'info');
                setProcessing(true);

                switch (strategy) {
                    case 'complete-replace':
                        await importCompleteReplace();
                        break;
                    case 'smart-update':
                        await importSmartUpdate();
                        break;
                    default:
                        await importCompleteReplace();
                        break;
                }

                if (importBtn) {
                    importBtn.disabled = true;
                    importBtn.textContent = 'Import Complete';
                }

            } catch (error) {
                console.error('Import error:', error);
                showStatus(`‚ùå Import failed: ${error.message}`, 'error');
            } finally {
                setProcessing(false);
            }
        }

        // Logic 1: Complete Replace - Delete entire table but keep structure, then import data from file
        async function importCompleteReplace() {
            showStatus('üóëÔ∏è Logic 1: Deleting all existing tickets (keeping table structure)...', 'info');

            // Delete all tickets but keep table structure
            const { error: deleteError } = await supabaseClient
                .from('tickets')
                .delete()
                .neq('id', 0); // Delete all rows

            if (deleteError) throw deleteError;

            showStatus('üì• Inserting all data from CSV file...', 'info');

            const ticketData = prepareTicketData(processedData);
            const { error: insertError } = await supabaseClient
                .from('tickets')
                .insert(ticketData);

            if (insertError) throw insertError;

            showStatus(`‚úÖ Ho√†n t·∫•t: ƒë√£ thay th·∫ø to√†n b·ªô b·∫£ng v·ªõi ${processedData.length} ticket m·ªõi t·ª´ file.`, 'success');
        }

        // Logic 2: Smart Update - Smart comparison with Re-Open detection
        async function importSmartUpdate() {
            showStatus('üîÑ Logic 2: B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t th√¥ng minh v·ªõi Re-Open...', 'info');

            // Get all ticket numbers from CSV
            const csvTicketNumbers = new Set(processedData.map(row => row.ticket).filter(t => t));

            // Step 1: Fetch ALL active (open, time_end IS NULL) tickets from DB
            showStatus('üìä B∆∞·ªõc 1: T·∫£i d·ªØ li·ªáu t·ª´ database...', 'info');
            const { data: activeTickets, error: activeError } = await supabaseClient
                .from('tickets')
                .select('id, ticket, time_start, needMos, ticket_status_id, need_leader_support, agent_handle_ticket, assignee_account')
                .is('time_end', null);

            if (activeError) throw activeError;

            // Step 2: Fetch completed tickets that match CSV ticket numbers (for Re-Open detection)
            const { data: completedTickets, error: completedError } = await supabaseClient
                .from('tickets')
                .select('id, ticket')
                .in('ticket', [...csvTicketNumbers])
                .not('time_end', 'is', null);

            if (completedError) throw completedError;

            // Build lookup maps
            const activeMap = new Map((activeTickets || []).map(t => [String(t.ticket), t]));
            const completedSet = new Set((completedTickets || []).map(t => String(t.ticket)));

            const toInsert = [];    // Brand new tickets
            const toUpdate = [];    // Active untouched tickets to update
            const toReopen = [];    // Completed tickets reappearing ‚Üí create Re-Open row
            const toDelete = [];    // Active untouched tickets not in CSV ‚Üí delete
            let skippedTouched = 0; // Active touched tickets ‚Üí keep as is

            // Step 3: Classify each CSV row
            showStatus('üìä B∆∞·ªõc 2: Ph√¢n lo·∫°i d·ªØ li·ªáu...', 'info');
            for (const row of processedData) {
                const ticketNum = String(row.ticket);
                const activeExisting = activeMap.get(ticketNum);
                const hasCompleted = completedSet.has(ticketNum);

                if (!activeExisting && !hasCompleted) {
                    // Ticket does not exist at all ‚Üí insert new
                    toInsert.push(row);
                } else if (!activeExisting && hasCompleted) {
                    // Ticket was completed but reappears in CSV ‚Üí Re-Open
                    toReopen.push(row);
                } else if (activeExisting) {
                    const isTouched =
                        activeExisting.needMos != null ||
                        activeExisting.ticket_status_id != null ||
                        activeExisting.need_leader_support === true ||
                        activeExisting.time_start != null ||
                        activeExisting.agent_handle_ticket != null;

                    if (isTouched) {
                        // Ticket is being worked on ‚Üí keep as is
                        skippedTouched++;
                    } else {
                        // Ticket exists but untouched ‚Üí update fields from CSV
                        toUpdate.push({ ...row, _existingId: activeExisting.id });
                    }
                }
            }

            // Step 4: Find active untouched tickets NOT in CSV ‚Üí delete them
            showStatus('üóëÔ∏è B∆∞·ªõc 3: T√¨m ticket c·∫ßn x√≥a...', 'info');
            for (const activeTicket of (activeTickets || [])) {
                if (!csvTicketNumbers.has(String(activeTicket.ticket))) {
                    const isTouched =
                        activeTicket.needMos != null ||
                        activeTicket.ticket_status_id != null ||
                        activeTicket.need_leader_support === true ||
                        activeTicket.time_start != null ||
                        activeTicket.agent_handle_ticket != null;

                    if (!isTouched) {
                        toDelete.push(activeTicket);
                    }
                }
            }

            // Step 5: Execute all operations
            let deletedCount = 0;
            if (toDelete.length > 0) {
                showStatus(`üóëÔ∏è ƒêang x√≥a ${toDelete.length} ticket kh√¥ng c√≤n trong file...`, 'info');
                const { error: deleteError } = await supabaseClient
                    .from('tickets')
                    .delete()
                    .in('id', toDelete.map(t => t.id));
                if (deleteError) throw deleteError;
                deletedCount = toDelete.length;
            }

            let updatedCount = 0;
            if (toUpdate.length > 0) {
                showStatus(`‚úèÔ∏è ƒêang c·∫≠p nh·∫≠t ${toUpdate.length} ticket...`, 'info');
                for (const row of toUpdate) {
                    const { error: updateError } = await supabaseClient
                        .from('tickets')
                        .update({
                            po: row.po,
                            suid: row.suid,
                            su_name: row.su_name,
                            supplier_agent_need: row.supplier_agent_need,
                            supplier_agent: row.supplier_agent,
                            order_number: row.order_number,
                            po_nocs: row.po_nocs,
                            customer: row.customer,
                            customer_contact: row.customer_contact,
                            issue_type: row.issue_type,
                            issue_id: row.issue_id,
                            description_eng: row.description_eng,
                            description_vie: row.description_vie,
                            assignee_account: row.agent_account
                        })
                        .eq('id', row._existingId);
                    if (updateError) throw updateError;
                    updatedCount++;
                }
            }

            if (toInsert.length > 0) {
                showStatus(`‚ûï ƒêang th√™m ${toInsert.length} ticket m·ªõi...`, 'info');
                const insertData = prepareTicketData(toInsert);
                const { error: insertError } = await supabaseClient
                    .from('tickets')
                    .insert(insertData);
                if (insertError) throw insertError;
            }

            if (toReopen.length > 0) {
                showStatus(`üîÑ ƒêang t·∫°o ${toReopen.length} ticket Re-Open...`, 'info');
                const reopenData = prepareTicketData(toReopen).map(t => ({
                    ...t,
                    notes: 'RE-OPEN'
                }));
                const { error: reopenError } = await supabaseClient
                    .from('tickets')
                    .insert(reopenData);
                if (reopenError) throw reopenError;
            }

            const statusMessage = `‚úÖ Logic 2 ho√†n t·∫•t: üÜï${toInsert.length} m·ªõi, ‚úèÔ∏è${updatedCount} c·∫≠p nh·∫≠t, üîÑ${toReopen.length} Re-Open, üóëÔ∏è${deletedCount} ƒë√£ x√≥a, ‚úã${skippedTouched} gi·ªØ nguy√™n`;
            showStatus(statusMessage, 'success');
        }





        // Helper function to prepare ticket data for insert/update
        function prepareTicketData(dataArray) {
            return dataArray.map(row => ({
                ticket: row.ticket,
                po: row.po,
                suid: row.suid,
                su_name: row.su_name,
                supplier_agent_need: row.supplier_agent_need,
                supplier_agent: row.supplier_agent,
                order_number: row.order_number,
                po_nocs: row.po_nocs,
                customer: row.customer,
                customer_contact: row.customer_contact,
                issue_type: row.issue_type,
                issue_id: row.issue_id,
                description_eng: row.description_eng,
                description_vie: row.description_vie,
                assignee_account: row.agent_account,
                time_start: null,
                time_end: null,
                agent_handle_ticket: null,
                ticket_status_id: null
            }));
        }

        function downloadProcessedCSV() {
            if (processedData.length === 0) {
                showStatus('No data to download', 'error');
                return;
            }

            const headers = Object.keys(processedData[0]);
            const csvContent = [
                headers.join(','),
                ...processedData.map(row =>
                    headers.map(header => {
                        const value = row[header] === null || row[header] === undefined ? '' : String(row[header]);
                        return `"${value.replace(/"/g, '""')}"`;
                    }).join(',')
                )
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `processed_tickets_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            showStatus('CSV file downloaded', 'success');
        }

        // UI helper functions
        function setProcessing(processing) {
            if (processBtn) processBtn.disabled = processing;
            if (processing) {
                if (processText) processText.textContent = 'Processing...';
                if (processSpinner) processSpinner.classList.remove('hidden');
            } else {
                if (processText) processText.textContent = 'Process CSV';
                if (processSpinner) processSpinner.classList.add('hidden');
            }
        }

        function showProgressPanel() {
            if (!progressPanel) return;
            progressPanel.classList.remove('hidden');
            for (let i = 1; i <= 3; i++) {
                updateStep(i, 'pending', getStepText(i));
            }
        }

        function updateStep(stepNumber, status, text) {
            const icon = document.getElementById(`step${stepNumber}-icon`);
            const textEl = document.getElementById(`step${stepNumber}-text`);
            if (!icon || !textEl) return;

            icon.className = 'w-6 h-6 rounded-full flex items-center justify-center mr-3';

            switch (status) {
                case 'pending':
                    icon.classList.add('bg-gray-300');
                    icon.innerHTML = `<span class="text-xs text-white">${stepNumber}</span>`;
                    break;
                case 'processing':
                    icon.classList.add('bg-blue-500');
                    icon.innerHTML = '<div class="loading-spinner w-3 h-3"></div>';
                    break;
                case 'complete':
                    icon.classList.add('bg-green-500');
                    icon.innerHTML = '<svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>';
                    break;
                case 'error':
                    icon.classList.add('bg-red-500');
                    icon.innerHTML = '<svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>';
                    break;
            }

            textEl.textContent = text;
        }

        function getStepText(stepNumber) {
            switch (stepNumber) {
                case 1: return 'Parse CSV file';
                case 2: return 'Process with AI';
                case 3: return 'Prepare for import';
                default: return '';
            }
        }

        function getCurrentStep() {
            if (document.getElementById('step3-icon')?.classList.contains('bg-blue-500')) return 3;
            if (document.getElementById('step2-icon')?.classList.contains('bg-blue-500')) return 2;
            return 1;
        }











        // Theme switcher logic
        function toggleThemeDropdown() {
            const themeDropdown = document.getElementById('theme-dropdown');
            const themeChevron = document.getElementById('theme-chevron');
            const isHidden = themeDropdown.classList.contains('hidden');

            if (isHidden) {
                themeDropdown.classList.remove('hidden');
                themeChevron.style.transform = 'rotate(180deg)';
            } else {
                themeDropdown.classList.add('hidden');
                themeChevron.style.transform = 'rotate(0deg)';
            }
        }

        function hideThemeDropdown() {
            const themeDropdown = document.getElementById('theme-dropdown');
            const themeChevron = document.getElementById('theme-chevron');
            themeDropdown.classList.add('hidden');
            themeChevron.style.transform = 'rotate(0deg)';
        }

        function setTheme(theme) {
            document.documentElement.className = theme;
            localStorage.setItem('theme', theme);

            // Update theme buttons
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.theme === theme);
            });

            // Update current theme name display
            const currentThemeName = document.getElementById('current-theme-name');
            const themeNames = {
                'dark': 'üåô T·ªëi',
                'daylight': '‚òÄÔ∏è Ban ng√†y',
                'sunset': 'üåÖ Ho√†ng h√¥n',
                'twilight': 'üåÜ Ch·∫°ng v·∫°ng',
                'blossom-dawn': 'üå∏ B√¨nh minh',
                'blue-sky': 'üå§Ô∏è Tr·ªùi xanh',
                'fresh-mint': 'üåø B·∫°c h√†'
            };
            if (currentThemeName) {
                currentThemeName.textContent = themeNames[theme] || theme;
            }
        }

        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            setTheme(savedTheme);

            // Add event listeners for theme functionality
            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const themeDropdown = document.getElementById('theme-dropdown');

            if (themeToggleBtn) {
                themeToggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleThemeDropdown();
                });
            }

            if (themeDropdown) {
                themeDropdown.addEventListener('click', (e) => {
                    if (e.target.matches('.theme-btn')) {
                        const theme = e.target.dataset.theme;
                        if (theme) {
                            setTheme(theme);
                            hideThemeDropdown();
                        }
                    }
                });
            }

            // Close theme dropdown when clicking outside
            document.addEventListener('click', (e) => {
                const themeToggleBtn = document.getElementById('theme-toggle-btn');
                const themeDropdown = document.getElementById('theme-dropdown');
                if (themeToggleBtn && themeDropdown &&
                    !themeToggleBtn.contains(e.target) && !themeDropdown.contains(e.target)) {
                    hideThemeDropdown();
                }
            });
        }

        document.addEventListener('DOMContentLoaded', initTheme);

    </script>
</body>
</html>
