/********************** CONFIGURATION **********************/
const SHEET_ID = '1NfwtNf9KgHeL5tdiOmJIfBOqTvGMiTcPSPEt4f_ZVSc';

// Tên các sheet
const SHEET_AOPS = 'Work tracker (AOPS)';
const SHEET_FMOP = 'Work tracker (FMOP)';
const SHEET_OT_TRACKER = 'OT Tracker';

// Cấu hình Supabase
const SUPABASE_URL = 'https://pfbxtbydrjcmqlrklsdr.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBmYnh0YnlkcmpjbXFscmtsc2RyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1Njk4MzY0OSwiZXhwIjoyMDcyNTU5NjQ5fQ._cMTCJnzN0TWw_nBRhR4mfNcDhQAo26jjdnIB8imD78';
const SECRET_TOKEN = '14092000'; 

// CẤU HÌNH DÒNG
const HEADER_ROW = 2;       // Tên cột nằm ở dòng 2
const DATA_START_ROW = 3;   // Dữ liệu bắt đầu điền từ dòng 3

// Cấu hình TÊN CỘT TRONG GOOGLE SHEET
const TRACKER_COLUMNS = {
  DATE: 'Date',
  TICKET_NUMBER: 'Ticket Number',
  START_TIME: 'Start Time',
  END_TIME: 'End Time',
  NAME: 'Name',
  ACCOUNT: 'Account',
  TICKET_TYPE: 'Ticket Type',
  SUPPLIER: 'Supplier',
  PO: 'PO(s)',
  TICKET_STATUS: 'Ticket Status'
};

const DATE_FORMAT_FOR_TRACKER = "MM/dd/yyyy";
const DATE_COMPLETED_FORMAT = "MM/dd/yyyy";

/********************** MAIN ENTRY POINT **********************/
function doGet(e) {
  const callback = e.parameter.callback;
  
  if (!e.parameter.secret || e.parameter.secret !== SECRET_TOKEN) {
    return createResponse({ error: 'Invalid secret token' }, callback);
  }

  const ticketId = e.parameter.ticketId;
  if (!ticketId) {
    return createResponse({ error: 'Missing ticketId' }, callback);
  }

  try {
    // 1. Gọi Supabase (Bên ngoài Lock để không nghẽn hệ thống khi mạng chậm)
    const ticketData = fetchTicketFromView(ticketId);
    if (!ticketData || ticketData.length === 0) {
       throw new Error(`Ticket ${ticketId} không tồn tại trên Supabase View`);
    }

    // 2. Bật Lock (Giới hạn chờ 30 giây để tránh Exceeded Time Limit)
    const lock = LockService.getScriptLock();
    const success = lock.tryLock(60000); 

    if (!success) {
       throw new Error("Server đang bận xử lý request khác. Vui lòng thử lại sau vài giây.");
    }

    let result;
    try {
      // 3. Xử lý ghi dữ liệu vào Sheet
      result = processTicketIntoSheet(ticketData[0]);
    } finally {
      // Nhả Lock ngay lập tức sau khi ghi xong
      lock.releaseLock();
    }

    // 4. Cập nhật trạng thái trên Supabase
    markTicketAsImported(ticketId);

    return createResponse(result, callback);

  } catch (err) {
    return createResponse({ success: false, error: err.message }, callback);
  }
}

/********************** CORE LOGIC **********************/
function processTicketIntoSheet(ticket) {
  const ticketNumber = String(ticket['Ticket'] || ''); 
  const project = String(ticket['Project'] || '');
  const isOt = ticket['OT Mode'] === true;

  // Chuẩn bị ngày so sánh
  const timeZone = Session.getScriptTimeZone();
  const today = new Date();
  const todayStr = Utilities.formatDate(today, timeZone, DATE_FORMAT_FOR_TRACKER);
  const completedDateStr = Utilities.formatDate(today, timeZone, DATE_COMPLETED_FORMAT);

  // Chọn Sheet phù hợp
  let sheetName = SHEET_AOPS; 
  if (isOt) sheetName = SHEET_OT_TRACKER;
  else if (ticketNumber.toUpperCase().startsWith('POS')) sheetName = SHEET_AOPS;
  else if (project === 'FMOP') sheetName = SHEET_FMOP;

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) throw new Error(`Không tìm thấy sheet: ${sheetName}`);

  // --- CACHE HEADERS (Tránh đọc lại nhiều lần) ---
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  const headers = getOrCacheHeaders(sheet, lastCol);
  const normalize = (str) => String(str || '').toLowerCase().replace(/\s+/g, '').trim();
  
  const dateColIdx = headers.findIndex(h => normalize(h) === normalize(TRACKER_COLUMNS.DATE));
  const ticketColIdx = headers.findIndex(h => normalize(h) === normalize(TRACKER_COLUMNS.TICKET_NUMBER));

  if (dateColIdx === -1 || ticketColIdx === -1) {
    throw new Error(`Lỗi cấu hình: Không tìm thấy cột Date hoặc Ticket Number`);
  }

  // --- QUÉT CHỈ 2 CỘT CẦN THIẾT (Date + Ticket) THAY VÌ TẤT CẢ CÁC CỘT ---
  const SCAN_LIMIT = 5000; // Tăng từ 3000 lên 5000 vì chỉ đọc 2 cột
  let startScanRow = DATA_START_ROW;

  if (lastRow > (DATA_START_ROW + SCAN_LIMIT)) {
    startScanRow = lastRow - SCAN_LIMIT + 1;
  }

  let dateColumn = [];
  let ticketColumn = [];

  if (lastRow >= startScanRow) {
    const numRows = lastRow - startScanRow + 1;
    // ĐỌC RIÊNG 2 CỘT thay vì đọc toàn bộ dữ liệu
    dateColumn = sheet.getRange(startScanRow, dateColIdx + 1, numRows, 1).getValues().map(r => r[0]);
    ticketColumn = sheet.getRange(startScanRow, ticketColIdx + 1, numRows, 1).getValues().map(r => r[0]);
  }

  // --- TÌM TRÙNG LẶP & DÒNG TRỐNG (Tối ưu vòng lặp) ---
  let targetRow = -1;
  let isUpdate = false;
  let firstEmptyRowIndex = -1;

  for (let i = 0; i < dateColumn.length; i++) {
    const rowTicket = String(ticketColumn[i] || '').trim();
    const rowDateRaw = dateColumn[i];

    let rowDateStr = '';
    if (rowDateRaw instanceof Date) {
      rowDateStr = Utilities.formatDate(rowDateRaw, timeZone, DATE_FORMAT_FOR_TRACKER);
    } else {
      rowDateStr = String(rowDateRaw || '').trim();
    }

    // Ưu tiên 1: Update nếu trùng Ticket + trùng Ngày hôm nay
    if (rowTicket === ticketNumber && rowDateStr === todayStr) {
      targetRow = startScanRow + i;
      isUpdate = true;
      break;
    }

    // Ưu tiên 2: Tìm dòng trống (chưa có Ticket và Date)
    if (firstEmptyRowIndex === -1 && rowTicket === '' && rowDateStr === '') {
      firstEmptyRowIndex = startScanRow + i;
    }
  }

  // Chốt vị trí ghi nếu không phải Update
  if (targetRow === -1) {
    if (firstEmptyRowIndex !== -1) {
      targetRow = firstEmptyRowIndex; // Ghi đè vào dòng trống
    } else {
      targetRow = lastRow + 1; // Ghi nối tiếp xuống cuối bảng
      if (targetRow < DATA_START_ROW) targetRow = DATA_START_ROW;
    }
  }

  // --- MAPPING DỮ LIỆU (Tối ưu với Map thay vì Object) ---
  const dataToMap = new Map([
    [TRACKER_COLUMNS.DATE, todayStr],
    [TRACKER_COLUMNS.TICKET_NUMBER, ticketNumber],
    [TRACKER_COLUMNS.START_TIME, ticket['Start Time'] || ''],
    [TRACKER_COLUMNS.END_TIME, ticket['End Time'] || ''],
    [TRACKER_COLUMNS.NAME, ticket['Name'] || ''],
    [TRACKER_COLUMNS.ACCOUNT, ticket['Account'] || ''],
    [TRACKER_COLUMNS.TICKET_TYPE, ticket['Ticket Type'] || ''],
    [TRACKER_COLUMNS.SUPPLIER, ticket['Supplier'] || ''],
    [TRACKER_COLUMNS.PO, ticket['PO'] || ''],
    [TRACKER_COLUMNS.TICKET_STATUS, ticket['Ticket Status'] || '']
  ]);

  // Bảo toàn công thức tại dòng được ghi (CHỈ ĐỌC KHI CẦN)
  let currentRowFormulas = [];
  if (targetRow <= sheet.getLastRow()) {
     currentRowFormulas = sheet.getRange(targetRow, 1, 1, lastCol).getFormulas()[0];
  }

  // Tạo normalized header map một lần
  const normalizedHeaders = headers.map(h => normalize(h));
  const dataMapKeys = Array.from(dataToMap.keys()).map(k => normalize(k));

  const newRowData = new Array(lastCol).fill('');
  const dateCompletedIdx = normalizedHeaders.findIndex(h => h.includes('datecompleted'));
  if (dateCompletedIdx !== -1) newRowData[dateCompletedIdx] = completedDateStr;

  for (let i = 0; i < headers.length; i++) {
    const headerNorm = normalizedHeaders[i];
    const mappedKeyIdx = dataMapKeys.indexOf(headerNorm);

    if (mappedKeyIdx !== -1) {
      const originalKey = Array.from(dataToMap.keys())[mappedKeyIdx];
      newRowData[i] = dataToMap.get(originalKey);
    } else if (currentRowFormulas[i] && currentRowFormulas[i] !== '') {
      newRowData[i] = currentRowFormulas[i];
    }
  }

  // --- THỰC THI GHI DỮ LIỆU ---
  sheet.getRange(targetRow, 1, 1, newRowData.length).setValues([newRowData]);

  return { 
    success: true, 
    row: targetRow, 
    sheet: sheetName, 
    ticket: ticketNumber, 
    action: isUpdate ? 'updated' : (firstEmptyRowIndex !== -1 ? 'filled_empty' : 'appended')
  };
}

/********************** HELPERS **********************/
// Cache headers để tránh đọc lại nhiều lần (giảm API calls)
const HEADER_CACHE = {};
function getOrCacheHeaders(sheet, lastCol) {
  const sheetName = sheet.getName();
  if (!HEADER_CACHE[sheetName]) {
    HEADER_CACHE[sheetName] = sheet.getRange(HEADER_ROW, 1, 1, lastCol).getValues()[0];
  }
  return HEADER_CACHE[sheetName];
}

function createResponse(data, callbackName) {
  const jsonString = JSON.stringify(data);
  return ContentService.createTextOutput(callbackName ? `${callbackName}(${jsonString})` : jsonString)
    .setMimeType(callbackName ? ContentService.MimeType.JAVASCRIPT : ContentService.MimeType.JSON);
}

function fetchTicketFromView(ticketId) {
  const url = `${SUPABASE_URL}/rest/v1/tickets_export_v?id=eq.${ticketId}&select=*`;
  const options = {
    method: 'GET',
    headers: {
      'apikey': SUPABASE_KEY,
      'Authorization': 'Bearer ' + SUPABASE_KEY,
      'Content-Type': 'application/json'
    },
    muteHttpExceptions: true,
    validateHttpsCertificates: false // Tăng tốc bỏ qua SSL validation
  };

  const response = UrlFetchApp.fetch(url, options);

  if (response.getResponseCode() !== 200) {
     throw new Error("Lỗi Supabase: " + response.getContentText());
  }
  return JSON.parse(response.getContentText());
}

function markTicketAsImported(ticketId) {
  try {
    const url = `${SUPABASE_URL}/rest/v1/tickets?id=eq.${ticketId}`;
    const options = {
      method: 'PATCH',
      headers: {
        'apikey': SUPABASE_KEY,
        'Authorization': 'Bearer ' + SUPABASE_KEY,
        'Content-Type': 'application/json',
        'Prefer': 'return=minimal'
      },
      payload: JSON.stringify({ import_to_tracker: true }),
      muteHttpExceptions: true,
      validateHttpsCertificates: false // Tăng tốc bỏ qua SSL validation
    };

    UrlFetchApp.fetch(url, options);
  } catch (e) {
    // Bỏ qua lỗi ngầm để không làm ảnh hưởng luồng chính nếu Supabase API chậm
    Logger.log('Error marking ticket as imported: ' + e.message);
  }
}