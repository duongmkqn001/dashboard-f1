/********************** C√ÅC GI√Å TR·ªä B·∫†N C·∫¶N T·ª∞ THI·∫æT L·∫¨P **********************/

// 1. ID c·ªßa file Google Sheet (l·∫•y t·ª´ URL)
const SHEET_ID = '1fiKKKBYQUHg5Apq-VuQPTiCtGwusW-IOl7KJhMyL764';

// 2. T√™n c√°c sheet t∆∞∆°ng ·ª©ng v·ªõi project
const SHEET_AOPS = 'Work tracker (AOPS)';
const SHEET_FMOP = 'Work tracker (FMOP)';

// 3. SERVICE ROLE KEY t·ª´ Supabase (Project Settings -> API -> Service role key)
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBmYnh0YnlkcmpjbXFscmtsc2RyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1Njk4MzY0OSwiZXhwIjoyMDcyNTU5NjQ5fQ._cMTCJnzN0TWw_nBRhR4mfNcDhQAo26jjdnIB8imD78';

// 4. M·ªôt chu·ªói k√Ω t·ª± b√≠ m·∫≠t b·∫•t k·ª≥ ƒë·ªÉ b·∫£o v·ªá Web App c·ªßa b·∫°n
const SECRET_TOKEN = '14092000'; // V√≠ d·ª•: 'Supa2Sheet!@#'

// 5. QUAN TR·ªåNG: Li·ªát k√™ t√™n ch√≠nh x√°c c·ªßa c√°c c·ªôt ch·ª©a C√îNG TH·ª®C ƒë·ªÉ script kh√¥ng ghi ƒë√®
const FORMULA_COLUMNS = ['Hr logged', 'Link','PO Count','Week CompletLi','Month Completed','Team']; // <-- TH√äM T√äN C·ªòT C√ì C√îNG TH·ª®C V√ÄO ƒê√ÇY


/********************** C·∫§U H√åNH C·ªê ƒê·ªäNH (KH√îNG C·∫¶N S·ª¨A) **********************/
const TRACKER_COLUMNS = {
  DATE:            'Date',
  TICKET_NUMBER:   'Ticket Number',
  START_TIME:      'Start Time',
  END_TIME:        'End Time',
  NAME:            'Name',
  ACCOUNT:         'Account',
  TICKET_TYPE:     'Ticket Type',
  SUPPLIER:        'Supplier',
  PO:              'PO(s)',
  TICKET_STATUS:   'Ticket Status'
};

const DATE_FORMAT_FOR_TRACKER = 'M/d/yyyy';
const DATE_COMPLETED_FORMAT   = 'MM/dd/yyyy';

/********************** WEB APP - ENTRY POINT **********************/
// Handle GET requests (supports JSONP callback to avoid CORS issues)
function doGet(e) {
  const startTime = new Date();
  let ticketId = 'unknown';

  try {
    const secret = e.parameter.secret;
    if (secret !== SECRET_TOKEN) {
      throw new Error('Invalid secret token.');
    }

    ticketId = e.parameter.ticketId;
    if (!ticketId) {
      throw new Error('Missing ticket ID.');
    }

    console.log(`üîÑ Processing ticket ${ticketId} - Start time: ${startTime.toISOString()}`);

    // Fetch ticket data from tickets_export_v view
    const ticketData = fetchTicketFromView(ticketId);
    if (!ticketData) {
      throw new Error('Ticket not found in export view or already imported.');
    }

    console.log(`üìä Fetched ticket data for ${ticketId}: ${ticketData['Ticket']}`);

    // Add ticket to Google Sheet
    addSingleTicketToSheet(ticketData);

    // Mark ticket as imported in Supabase
    markTicketAsImported(ticketId);

    const endTime = new Date();
    const processingTime = endTime - startTime;
    console.log(`‚úÖ Successfully processed ticket ${ticketId} in ${processingTime}ms`);

    const response = {
      status: 'success',
      ticketNumber: ticketData['Ticket'],
      processingTime: processingTime
    };

    // Support JSONP callback for CORS bypass
    const callback = e.parameter.callback;
    if (callback) {
      return ContentService
        .createTextOutput(callback + '(' + JSON.stringify(response) + ')')
        .setMimeType(ContentService.MimeType.JAVASCRIPT);
    }

    // Regular JSON response
    return ContentService
      .createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    const endTime = new Date();
    const processingTime = endTime - startTime;
    console.error(`‚ùå Error processing ticket ${ticketId} after ${processingTime}ms:`, error.message, error.stack);

    const errorResponse = {
      status: 'error',
      message: error.message,
      ticketId: ticketId,
      processingTime: processingTime
    };

    // Support JSONP callback even for errors
    const callback = e.parameter.callback;
    if (callback) {
      return ContentService
        .createTextOutput(callback + '(' + JSON.stringify(errorResponse) + ')')
        .setMimeType(ContentService.MimeType.JAVASCRIPT);
    }

    return ContentService
      .createTextOutput(JSON.stringify(errorResponse))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/********************** FETCH TICKET FROM VIEW **********************/
function fetchTicketFromView(ticketId) {
  try {
    const url = 'https://pfbxtbydrjcmqlrklsdr.supabase.co/rest/v1/tickets_export_v?id=eq.' + ticketId;

    const options = {
      method: 'GET',
      headers: {
        'apikey': SUPABASE_KEY,
        'Authorization': 'Bearer ' + SUPABASE_KEY
      }
    };

    const response = UrlFetchApp.fetch(url, options);
    const data = JSON.parse(response.getContentText());

    if (!data || data.length === 0) {
      return null;
    }

    // Return the first (and should be only) result
    return data[0];
  } catch (error) {
    console.error('Error fetching ticket from view:', error.message);
    throw new Error('Failed to fetch ticket data: ' + error.message);
  }
}

/********************** CORE LOGIC - X·ª¨ L√ù 1 TICKET **********************/
function addSingleTicketToSheet(ticket) {
  // ticket data comes from tickets_export_v view with all fields properly formatted
  const project = String(ticket['Project'] || '');
  let sheetName;
  if (project === 'AOPS') sheetName = SHEET_AOPS;
  else if (project === 'FMOP') sheetName = SHEET_FMOP;
  else throw new Error(`Unknown project: ${project} for ticket ${ticket['Ticket']}`);

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) throw new Error(`Sheet not found: ${sheetName}`);

  // Use lock to prevent concurrent access conflicts
  const lock = LockService.getScriptLock();
  try {
    // Wait up to 30 seconds for the lock
    lock.waitLock(30000);

    const header = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const headerTrimmed = header.map(h => String(h).trim());
    const formulaColumnsSet = new Set(FORMULA_COLUMNS.map(c => c.trim()));

    const colIndex = (name) => {
      const i = headerTrimmed.indexOf(name);
      return i;
    };

    const today = new Date();
    const todayStrTracker = Utilities.formatDate(today, Session.getScriptTimeZone(), DATE_FORMAT_FOR_TRACKER);
    const todayMMDDYYYY = Utilities.formatDate(today, Session.getScriptTimeZone(), DATE_COMPLETED_FORMAT);

    // Improved row finding logic - always append to end to avoid conflicts
    // This is safer than trying to find blank rows which can cause race conditions
    const targetRow = sheet.getLastRow() + 1;

    console.log(`Adding ticket ${ticket['Ticket']} to row ${targetRow} in sheet ${sheetName}`);

    // Prepare data for insertion
    const newRowData = new Array(header.length).fill('');

    // Map ticket data to sheet columns
    const dataToMap = {
      [TRACKER_COLUMNS.DATE]: todayStrTracker,
      [TRACKER_COLUMNS.TICKET]: ticket['Ticket'] || '',
      [TRACKER_COLUMNS.TICKET_TYPE]: ticket['Ticket Type'] || '',
      [TRACKER_COLUMNS.SUPPLIER]: ticket['Supplier'] || '',
      [TRACKER_COLUMNS.START_TIME]: ticket['Start Time'] || '',
      [TRACKER_COLUMNS.END_TIME]: ticket['End Time'] || '',
      [TRACKER_COLUMNS.NAME]: ticket['Name'] || '',
      [TRACKER_COLUMNS.ACCOUNT]: ticket['Account'] || '',
      [TRACKER_COLUMNS.TICKET_STATUS]: ticket['Ticket Status'] || '',
      [TRACKER_COLUMNS.DATE_COMPLETED]: todayMMDDYYYY
    };

    for (const colName in dataToMap) {
      // Only fill data if column exists and is not a formula column
      if (dataToMap.hasOwnProperty(colName) && !formulaColumnsSet.has(colName)) {
        const idx = colIndex(colName);
        if (idx !== -1) {
          newRowData[idx] = dataToMap[colName] ?? '';
        }
      }
    }

    // Insert data at the target row (always append to end)
    const range = sheet.getRange(targetRow, 1, 1, newRowData.length);
    range.setValues([newRowData]);

    console.log(`Successfully added ticket ${ticket['Ticket']} to row ${targetRow}`);

  } catch (error) {
    console.error('Error in addSingleTicketToSheet:', error);
    throw error;
  } finally {
    // Always release the lock
    lock.releaseLock();
  }

/********************** UPDATE SUPABASE - MARK IMPORTED **********************/
function markTicketAsImported(ticketId) {
  try {
    console.log(`üîÑ Marking ticket ${ticketId} as imported in Supabase...`);

    const url = 'https://pfbxtbydrjcmqlrklsdr.supabase.co/rest/v1/tickets?id=eq.' + ticketId;
    const payload = {
      import_to_tracker: true
    };

    const options = {
      method: 'PATCH',
      headers: {
        'apikey': SUPABASE_KEY,
        'Authorization': 'Bearer ' + SUPABASE_KEY,
        'Content-Type': 'application/json',
        'Prefer': 'return=minimal'
      },
      payload: JSON.stringify(payload)
    };

    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();

    if (responseCode === 204 || responseCode === 200) {
      console.log(`‚úÖ Successfully marked ticket ${ticketId} as imported in Supabase`);
      return true;
    } else {
      console.error(`‚ùå Failed to mark ticket ${ticketId} as imported. Status: ${responseCode}`);
      throw new Error(`Failed to mark ticket as imported. HTTP ${responseCode}: ${response.getContentText()}`);
    }
  } catch (error) {
    console.error(`‚ùå Error marking ticket ${ticketId} as imported:`, error.message);
    throw new Error('Failed to mark ticket as imported: ' + error.message);
  }
}