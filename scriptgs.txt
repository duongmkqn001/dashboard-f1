/********************** CÃC GIÃ TRá»Š Báº N Cáº¦N Tá»° THIáº¾T Láº¬P **********************/

// 1. ID cá»§a file Google Sheet (láº¥y tá»« URL)
const SHEET_ID = '1tYuKL6CCn0u4pWBBnYJ1dxVs4Dqp8kPxTuyYUpUpdQw';

// 2. TÃªn cÃ¡c sheet tÆ°Æ¡ng á»©ng vá»›i project
const SHEET_AOPS = 'Work tracker (AOPS)';
const SHEET_FMOP = 'Work tracker (FMOP)';
const SHEET_OT_TRACKER = 'OT Tracker';  // Sheet for OT Mode tickets

// 3. SERVICE ROLE KEY tá»« Supabase (Project Settings -> API -> Service role key)
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBmYnh0YnlkcmpjbXFscmtsc2RyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1Njk4MzY0OSwiZXhwIjoyMDcyNTU5NjQ5fQ._cMTCJnzN0TWw_nBRhR4mfNcDhQAo26jjdnIB8imD78';

// 4. Má»™t chuá»—i kÃ½ tá»± bÃ­ máº­t báº¥t ká»³ Ä‘á»ƒ báº£o vá»‡ Web App cá»§a báº¡n
const SECRET_TOKEN = '14092000'; // VÃ­ dá»¥: 'Supa2Sheet!@#'

// 5. QUAN TRá»ŒNG: Liá»‡t kÃª tÃªn chÃ­nh xÃ¡c cá»§a cÃ¡c cá»™t chá»©a CÃ”NG THá»¨C Ä‘á»ƒ script khÃ´ng ghi Ä‘Ã¨
const FORMULA_COLUMNS = ['Hr logged', 'Link','PO Count','Week CompletLi','Month Completed','Team']; // <-- THÃŠM TÃŠN Cá»˜T CÃ“ CÃ”NG THá»¨C VÃ€O ÄÃ‚Y


/********************** Cáº¤U HÃŒNH Cá» Äá»ŠNH (KHÃ”NG Cáº¦N Sá»¬A) **********************/
const TRACKER_COLUMNS = {
  DATE:            'Date',
  TICKET_NUMBER:   'Ticket Number',
  START_TIME:      'Start Time',
  END_TIME:        'End Time',
  NAME:            'Name',
  ACCOUNT:         'Account',
  TICKET_TYPE:     'Ticket Type',
  SUPPLIER:        'Supplier',
  PO:              'PO(s)',
  TICKET_STATUS:   'Ticket Status'
};

const DATE_FORMAT_FOR_TRACKER = 'M/d/yyyy';
const DATE_COMPLETED_FORMAT   = 'MM/dd/yyyy';

/********************** WEB APP - ENTRY POINT **********************/
// Handle GET requests (supports JSONP callback to avoid CORS issues)
function doGet(e) {
  const startTime = new Date();
  let ticketId = 'unknown';

  try {
    const secret = e.parameter.secret;
    if (secret !== SECRET_TOKEN) {
      throw new Error('Invalid secret token.');
    }

    ticketId = e.parameter.ticketId;
    if (!ticketId) {
      throw new Error('Missing ticket ID.');
    }

    console.log(`ðŸ”„ Processing ticket ${ticketId} - Start time: ${startTime.toISOString()}`);

    // Use lock immediately to prevent race conditions
    const lock = LockService.getScriptLock();
    try {
      // Shorter lock timeout to prevent delays
      lock.waitLock(10000); // 10 seconds instead of 30

      // Check if ticket is already imported to avoid duplicate processing
      const isAlreadyImported = checkIfTicketImported(ticketId);
      if (isAlreadyImported) {
        console.log(`âœ… Ticket ${ticketId} already imported, skipping`);

        const response = {
          status: 'success',
          message: 'Ticket already imported',
          ticketId: ticketId,
          alreadyImported: true
        };

        return createResponse(response, e.parameter.callback);
      }

      // Fetch ticket data from tickets_export_v view
      const ticketData = fetchTicketFromView(ticketId);
      if (!ticketData) {
        throw new Error('Ticket not found in export view. Check if ticket meets export criteria (has time_start, time_end, ticket_status_id, agent_handle_ticket).');
      }

      console.log(`ðŸ“Š Fetched ticket data for ${ticketId}: ${ticketData['Ticket']}`);

      // CRITICAL: Mark as imported BEFORE adding to sheet to prevent race conditions
      markTicketAsImported(ticketId);

      // Add ticket to Google Sheet with enhanced error handling
      const sheetResult = addSingleTicketToSheet(ticketData);

      const endTime = new Date();
      const processingTime = endTime - startTime;
      console.log(`âœ… Successfully processed ticket ${ticketId} in ${processingTime}ms`);

      const response = {
        status: 'success',
        ticketNumber: ticketData['Ticket'],
        processingTime: processingTime,
        sheetRow: sheetResult.row,
        sheetName: sheetResult.sheetName
      };

      return createResponse(response, e.parameter.callback);

    } finally {
      // Always release the lock
      lock.releaseLock();
    }

  } catch (error) {
    const endTime = new Date();
    const processingTime = endTime - startTime;
    console.error(`âŒ Error processing ticket ${ticketId} after ${processingTime}ms:`, error.message, error.stack);

    const errorResponse = {
      status: 'error',
      message: error.message,
      ticketId: ticketId,
      processingTime: processingTime,
      errorType: error.name || 'UnknownError'
    };

    return createResponse(errorResponse, e.parameter.callback);
  }
}

/********************** HELPER FUNCTION FOR RESPONSES **********************/
function createResponse(responseData, callback) {
  if (callback) {
    return ContentService
      .createTextOutput(callback + '(' + JSON.stringify(responseData) + ')')
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService
    .createTextOutput(JSON.stringify(responseData))
    .setMimeType(ContentService.MimeType.JSON);
}

/********************** CHECK IF TICKET ALREADY IMPORTED **********************/
function checkIfTicketImported(ticketId) {
  try {
    const url = 'https://pfbxtbydrjcmqlrklsdr.supabase.co/rest/v1/tickets?id=eq.' + ticketId + '&select=import_to_tracker';

    const options = {
      method: 'GET',
      headers: {
        'apikey': SUPABASE_KEY,
        'Authorization': 'Bearer ' + SUPABASE_KEY
      }
    };

    const response = UrlFetchApp.fetch(url, options);
    const data = JSON.parse(response.getContentText());

    if (!data || data.length === 0) {
      return false; // Ticket not found, assume not imported
    }

    return data[0].import_to_tracker === true;
  } catch (error) {
    console.error('Error checking if ticket is imported:', error.message);
    return false; // Assume not imported on error
  }
}

/********************** FETCH TICKET FROM VIEW **********************/
function fetchTicketFromView(ticketId) {
  try {
    const url = 'https://pfbxtbydrjcmqlrklsdr.supabase.co/rest/v1/tickets_export_v?id=eq.' + ticketId;

    const options = {
      method: 'GET',
      headers: {
        'apikey': SUPABASE_KEY,
        'Authorization': 'Bearer ' + SUPABASE_KEY
      }
    };

    const response = UrlFetchApp.fetch(url, options);
    const data = JSON.parse(response.getContentText());

    if (!data || data.length === 0) {
      return null;
    }

    // Return the first (and should be only) result
    return data[0];
  } catch (error) {
    console.error('Error fetching ticket from view:', error.message);
    throw new Error('Failed to fetch ticket data: ' + error.message);
  }
}

/********************** CORE LOGIC - Xá»¬ LÃ 1 TICKET **********************/
function addSingleTicketToSheet(ticket) {
  // ticket data comes from tickets_export_v view with all fields properly formatted
  const ticketNumber = String(ticket['Ticket'] || '');
  const project = String(ticket['Project'] || '');
  const otMode = ticket['OT Mode'] || false;
  
  let sheetName;
  
  // Priority 1: OT Mode tickets go to OT Tracker
  if (otMode === true) {
    sheetName = SHEET_OT_TRACKER;
    console.log(`ðŸ”¥ OT Mode ticket detected: ${ticketNumber} -> OT Tracker`);
  }
  // Priority 2: POS tickets always go to AOPS (regardless of project)
  else if (ticketNumber.toUpperCase().startsWith('POS')) {
    sheetName = SHEET_AOPS;
    console.log(`ðŸ“¦ POS ticket detected: ${ticketNumber} -> Work tracker (AOPS)`);
  }
  // Priority 3: Regular project routing
  else if (project === 'AOPS') {
    sheetName = SHEET_AOPS;
  } else if (project === 'FMOP') {
    sheetName = SHEET_FMOP;
  } else {
    throw new Error(`Unknown project: ${project} for ticket ${ticketNumber}`);
  }

  const ss = SpreadsheetApp.openById(SHEET_ID);
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) throw new Error(`Sheet not found: ${sheetName}`);

  // No lock here - lock is already acquired in doGet()
  const header = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const headerTrimmed = header.map(h => String(h).trim());
  const formulaColumnsSet = new Set(FORMULA_COLUMNS.map(c => c.trim()));

  const colIndex = (name) => {
    const i = headerTrimmed.indexOf(name);
    return i;
  };

  const today = new Date();
  const todayStrTracker = Utilities.formatDate(today, Session.getScriptTimeZone(), DATE_FORMAT_FOR_TRACKER);
  const todayMMDDYYYY = Utilities.formatDate(today, Session.getScriptTimeZone(), DATE_COMPLETED_FORMAT);

  // Find the nearest blank row by checking Date column
  const dateColIndex = colIndex(TRACKER_COLUMNS.DATE);
  let targetRow = -1;

  if (dateColIndex !== -1) {
    const lastRow = sheet.getLastRow();
    if (lastRow > 1) {
      // Read Date column to find first blank row
      const dataRange = sheet.getRange(2, dateColIndex + 1, lastRow - 1, 1).getValues();

      // Find first blank cell in Date column
      for (let i = 0; i < dataRange.length; i++) {
        const dateValue = dataRange[i][0];

        // Find first blank Date cell
        if (!dateValue || String(dateValue).trim() === '') {
          targetRow = i + 2; // +2 because: +1 for 0-index, +1 for header row
          break;
        }
      }
    }

    // If no blank row found, append to end
    if (targetRow === -1) {
      targetRow = sheet.getLastRow() + 1;
    }
  } else {
    // If Date column not found, append to end
    targetRow = sheet.getLastRow() + 1;
  }

  console.log(`Adding ticket ${ticket['Ticket']} to row ${targetRow} in sheet ${sheetName}`);

  // Prepare data for insertion
  const newRowData = new Array(header.length).fill('');

  // Get index of 'Ticket Status' column to determine 'Date Completed' position
  const ticketStatusIndex = colIndex(TRACKER_COLUMNS.TICKET_STATUS);
  let dateCompletedIndex = -1;
  if (ticketStatusIndex !== -1) {
    dateCompletedIndex = ticketStatusIndex + 1;
    // Fill Date Completed in the correct position
    newRowData[dateCompletedIndex] = todayMMDDYYYY;
  }

  // Map ticket data to sheet columns (using correct column names)
  const dataToMap = {
    [TRACKER_COLUMNS.DATE]: todayStrTracker,
    [TRACKER_COLUMNS.TICKET_NUMBER]: ticket['Ticket'] || '',
    [TRACKER_COLUMNS.START_TIME]: ticket['Start Time'] || '',
    [TRACKER_COLUMNS.END_TIME]: ticket['End Time'] || '',
    [TRACKER_COLUMNS.NAME]: ticket['Name'] || '',
    [TRACKER_COLUMNS.ACCOUNT]: ticket['Account'] || '',
    [TRACKER_COLUMNS.TICKET_TYPE]: ticket['Ticket Type'] || '',
    [TRACKER_COLUMNS.SUPPLIER]: ticket['Supplier'] || '',
    [TRACKER_COLUMNS.PO]: ticket['PO'] || '',
    [TRACKER_COLUMNS.TICKET_STATUS]: ticket['Ticket Status'] || '',
  };

  // Read existing formulas in the target row to protect them
  const existingFormulas = sheet.getRange(targetRow, 1, 1, header.length).getFormulas()[0];
  
  for (const colName in dataToMap) {
    if (dataToMap.hasOwnProperty(colName)) {
      const idx = colIndex(colName);
      if (idx !== -1) {
        // Check if column is marked as formula column OR already has a formula
        const hasFormula = existingFormulas[idx] && existingFormulas[idx].trim() !== '';
        const isProtectedColumn = formulaColumnsSet.has(colName);
        
        // Only write data if column is NOT protected and does NOT have a formula
        if (!isProtectedColumn && !hasFormula) {
          newRowData[idx] = dataToMap[colName] ?? '';
        } else if (hasFormula) {
          console.log(`âš ï¸ Skipping column "${colName}" at index ${idx} - contains formula: ${existingFormulas[idx]}`);
        } else if (isProtectedColumn) {
          console.log(`ðŸ”’ Skipping protected column "${colName}" at index ${idx}`);
        }
      }
    }
  }

  // Insert data at the target row (formulas will be preserved)
  const range = sheet.getRange(targetRow, 1, 1, newRowData.length);
  range.setValues([newRowData]);

  console.log(`Successfully added ticket ${ticket['Ticket']} to row ${targetRow}`);

  // Return success information
  return {
    success: true,
    row: targetRow,
    sheetName: sheetName,
    ticketNumber: ticket['Ticket']
  };
}

/********************** UPDATE SUPABASE - MARK IMPORTED **********************/
function markTicketAsImported(ticketId) {
  try {
    console.log(`ðŸ”„ Marking ticket ${ticketId} as imported in Supabase...`);

    const url = 'https://pfbxtbydrjcmqlrklsdr.supabase.co/rest/v1/tickets?id=eq.' + ticketId;
    const payload = {
      import_to_tracker: true
    };

    const options = {
      method: 'PATCH',
      headers: {
        'apikey': SUPABASE_KEY,
        'Authorization': 'Bearer ' + SUPABASE_KEY,
        'Content-Type': 'application/json',
        'Prefer': 'return=minimal'
      },
      payload: JSON.stringify(payload)
    };

    const response = UrlFetchApp.fetch(url, options);
    const responseCode = response.getResponseCode();

    if (responseCode === 204 || responseCode === 200) {
      console.log(`âœ… Successfully marked ticket ${ticketId} as imported in Supabase`);
      return true;
    } else {
      console.error(`âŒ Failed to mark ticket ${ticketId} as imported. Status: ${responseCode}`);
      throw new Error(`Failed to mark ticket as imported. HTTP ${responseCode}: ${response.getContentText()}`);
    }
  } catch (error) {
    console.error(`âŒ Error marking ticket ${ticketId} as imported:`, error.message);
    throw new Error('Failed to mark ticket as imported: ' + error.message);
  }
}