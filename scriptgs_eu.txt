/********************** CONFIGURATION - EU TRACKER **********************/
// NOTE: This script is bound to a Google Sheet, so no SHEET_ID needed
// All EU tickets go to ONE sheet (no separation by POS/AOPS/FMOP like NA)

// Cáº¥u hÃ¬nh Supabase
const SUPABASE_URL = 'https://pfbxtbydrjcmqlrklsdr.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBmYnh0YnlkcmpjbXFscmtsc2RyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1Njk4MzY0OSwiZXhwIjoyMDcyNTU5NjQ5fQ._cMTCJnzN0TWw_nBRhR4mfNcDhQAo26jjdnIB8imD78';
const SECRET_TOKEN = '14092000';

// Cáº¤U HÃŒNH DÃ’NG
const HEADER_ROW = 1;       // Headers in row 1
const DATA_START_ROW = 2;   // Data starts from row 2

/********************** MAIN FUNCTIONS **********************/

// Handle GET requests (from dashboard "End Ticket" button)
function doGet(e) {
    try {
        Logger.log('ğŸš€ === EU SINGLE TICKET IMPORT (GET) ===');
        Logger.log('ğŸ“¥ Received GET request');

        const params = e.parameter;
        Logger.log(`ğŸ“¦ Request params: ${JSON.stringify(params)}`);

        // Verify secret token
        if (params.secret !== SECRET_TOKEN) {
            Logger.log('âŒ Unauthorized: Invalid secret token');
            const response = {
                success: false,
                error: 'Unauthorized'
            };
            return ContentService.createTextOutput(
                `${params.callback}(${JSON.stringify(response)})`
            ).setMimeType(ContentService.MimeType.JAVASCRIPT);
        }

        // Get ticket ID
        const ticketId = params.ticketId;
        if (!ticketId) {
            Logger.log('âŒ Missing ticketId parameter');
            const response = {
                success: false,
                error: 'Missing ticketId parameter'
            };
            return ContentService.createTextOutput(
                `${params.callback}(${JSON.stringify(response)})`
            ).setMimeType(ContentService.MimeType.JAVASCRIPT);
        }

        Logger.log(`ğŸ« Processing ticket ID: ${ticketId}`);

        // Fetch single ticket from EU view
        const ticket = fetchSingleEUTicket(ticketId);

        if (!ticket) {
            Logger.log(`âŒ Ticket ${ticketId} not found in EU view`);
            const response = {
                success: false,
                error: `Ticket ${ticketId} khÃ´ng tá»“n táº¡i trÃªn Supabase View`
            };
            return ContentService.createTextOutput(
                `${params.callback}(${JSON.stringify(response)})`
            ).setMimeType(ContentService.MimeType.JAVASCRIPT);
        }

        // Import single ticket to sheet
        const result = importSingleTicketToEUSheet(ticket);

        Logger.log(`âœ… Import result: ${JSON.stringify(result)}`);

        // Return JSONP response
        const response = {
            success: result.success,
            message: result.message,
            ticketId: ticketId
        };

        return ContentService.createTextOutput(
            `${params.callback}(${JSON.stringify(response)})`
        ).setMimeType(ContentService.MimeType.JAVASCRIPT);

    } catch (error) {
        Logger.log(`âŒ Error in doGet: ${error.toString()}`);
        const response = {
            success: false,
            error: error.toString()
        };
        return ContentService.createTextOutput(
            `${e.parameter.callback}(${JSON.stringify(response)})`
        ).setMimeType(ContentService.MimeType.JAVASCRIPT);
    }
}

// Handle POST requests (from EU Import button)
function doPost(e) {
    try {
        Logger.log('ğŸš€ === EU BULK IMPORT (POST) ===');
        Logger.log('ğŸ“¥ Received POST request');

        // Verify secret token
        Logger.log('ğŸ” Verifying secret token...');
        const params = JSON.parse(e.postData.contents);
        Logger.log(`ğŸ“¦ Request params: ${JSON.stringify(params)}`);

        if (params.secret !== SECRET_TOKEN) {
            Logger.log('âŒ Unauthorized: Invalid secret token');
            return ContentService.createTextOutput(JSON.stringify({
                success: false,
                message: 'Unauthorized'
            })).setMimeType(ContentService.MimeType.JSON);
        }
        Logger.log('âœ… Secret token verified');

        // Fetch data from Supabase EU view
        Logger.log('ğŸ“¡ Fetching EU tickets from Supabase...');
        const tickets = fetchEUTicketsFromSupabase();
        Logger.log(`ğŸ“Š Received ${tickets ? tickets.length : 0} tickets from Supabase`);

        if (!tickets || tickets.length === 0) {
            Logger.log('âš ï¸ No EU tickets to import');
            return ContentService.createTextOutput(JSON.stringify({
                success: true,
                message: 'No EU tickets to import',
                count: 0
            })).setMimeType(ContentService.MimeType.JSON);
        }

        // Import to EU tracker sheet
        Logger.log('ğŸ“ Starting import to EU sheet...');
        const result = importToEUSheet(tickets);
        Logger.log(`âœ… Import completed: ${result.updated} new tickets added (${result.count} total processed)`);

        return ContentService.createTextOutput(JSON.stringify({
            success: true,
            message: 'EU tickets imported successfully',
            count: result.count,
            updated: result.updated
        })).setMimeType(ContentService.MimeType.JSON);

    } catch (error) {
        Logger.log('âŒ ERROR in doPost: ' + error.toString());
        Logger.log('ğŸ“ Error stack: ' + error.stack);
        return ContentService.createTextOutput(JSON.stringify({
            success: false,
            message: error.toString()
        })).setMimeType(ContentService.MimeType.JSON);
    }
}

/********************** FETCH DATA FROM SUPABASE **********************/
function fetchEUTicketsFromSupabase() {
    Logger.log('ğŸ” === FETCHING FROM SUPABASE ===');
    const url = `${SUPABASE_URL}/rest/v1/tickets_export_eu_v?select=*`;
    Logger.log(`ğŸŒ URL: ${url}`);

    const options = {
        method: 'get',
        headers: {
            'apikey': SUPABASE_KEY,
            'Authorization': `Bearer ${SUPABASE_KEY}`,
            'Content-Type': 'application/json'
        },
        muteHttpExceptions: true
    };

    try {
        Logger.log('ğŸ“¡ Sending request to Supabase...');
        const response = UrlFetchApp.fetch(url, options);
        const responseCode = response.getResponseCode();
        const responseText = response.getContentText();

        Logger.log(`ğŸ“Š Response Code: ${responseCode}`);
        Logger.log(`ğŸ“„ Response Text (first 500 chars): ${responseText.substring(0, 500)}`);

        if (responseCode !== 200) {
            Logger.log(`âŒ Supabase error - Status ${responseCode}`);
            Logger.log(`ğŸ“„ Full response: ${responseText}`);
            throw new Error(`Supabase returned status ${responseCode}: ${responseText}`);
        }

        Logger.log('ğŸ”„ Parsing JSON response...');
        const data = JSON.parse(responseText);

        if (!Array.isArray(data)) {
            Logger.log(`âŒ Invalid data type received: ${typeof data}`);
            throw new Error(`Expected array from Supabase, got: ${typeof data}`);
        }

        Logger.log(`âœ… Successfully fetched ${data.length} EU tickets from Supabase`);
        if (data.length > 0) {
            Logger.log(`ğŸ“‹ Sample ticket keys: ${Object.keys(data[0]).join(', ')}`);
            Logger.log(`ğŸ“ First ticket sample: ${JSON.stringify(data[0])}`);
        } else {
            Logger.log('âš ï¸ No tickets returned from view. Possible reasons:');
            Logger.log('   1. No EU team members have tickets');
            Logger.log('   2. All EU tickets already have import_to_tracker=true');
            Logger.log('   3. View tickets_export_eu_v might not exist');
        }

        return data;
    } catch (error) {
        Logger.log(`âŒ ERROR fetching from Supabase: ${error.toString()}`);
        Logger.log(`ğŸ“ Error stack: ${error.stack}`);
        throw error;
    }
}

// Fetch single ticket by ID from EU view
function fetchSingleEUTicket(ticketId) {
    Logger.log(`ğŸ” === FETCHING SINGLE TICKET ${ticketId} FROM EU VIEW ===`);
    const url = `${SUPABASE_URL}/rest/v1/tickets_export_eu_v?id=eq.${ticketId}&select=*`;
    Logger.log(`ğŸŒ URL: ${url}`);

    const options = {
        method: 'get',
        headers: {
            'apikey': SUPABASE_KEY,
            'Authorization': `Bearer ${SUPABASE_KEY}`,
            'Content-Type': 'application/json'
        },
        muteHttpExceptions: true
    };

    try {
        Logger.log('ğŸ“¡ Sending request to Supabase...');
        const response = UrlFetchApp.fetch(url, options);
        const responseCode = response.getResponseCode();
        const responseText = response.getContentText();

        Logger.log(`ğŸ“Š Response Code: ${responseCode}`);
        Logger.log(`ğŸ“„ Response: ${responseText}`);

        if (responseCode !== 200) {
            Logger.log(`âŒ Supabase error - Status ${responseCode}`);
            return null;
        }

        const data = JSON.parse(responseText);

        if (!data || data.length === 0) {
            Logger.log(`âš ï¸ Ticket ${ticketId} not found in EU view`);
            return null;
        }

        Logger.log(`âœ… Found ticket: ${JSON.stringify(data[0])}`);
        return data[0];

    } catch (error) {
        Logger.log(`âŒ ERROR fetching ticket: ${error.toString()}`);
        return null;
    }
}

/********************** IMPORT TO EU SHEET **********************/
function importToEUSheet(tickets) {
    Logger.log('ğŸ“Š === IMPORTING TO EU SHEET ===');

    try {
        // Use getActiveSpreadsheet() for bound scripts (no need for Sheet ID)
        Logger.log('ğŸ“‚ Getting active spreadsheet...');
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        Logger.log(`âœ… Spreadsheet: "${ss.getName()}"`);

        // Get the first (active) sheet - all EU tickets go to one sheet
        Logger.log('ğŸ“„ Getting active sheet...');
        const sheet = ss.getActiveSheet();

        if (!sheet) {
            Logger.log(`âŒ No active sheet found in spreadsheet: ${ss.getName()}`);
            throw new Error(`No active sheet found in spreadsheet: ${ss.getName()}`);
        }

        Logger.log(`âœ… Using sheet: "${sheet.getName()}"`);

        // Get existing data to avoid duplicates
        const lastRow = sheet.getLastRow();
        Logger.log(`ğŸ“ Last row in sheet: ${lastRow}`);

        const existingTickets = new Set();

        if (lastRow >= DATA_START_ROW) {
            Logger.log(`ğŸ” Reading existing tickets from row ${DATA_START_ROW} to ${lastRow}...`);
            // Read column 1 (Ticket Number column) to check for duplicates
            const existingData = sheet.getRange(DATA_START_ROW, 1, lastRow - DATA_START_ROW + 1, 1).getValues();
            existingData.forEach(row => {
                if (row[0]) existingTickets.add(row[0].toString());
            });
            Logger.log(`ğŸ“‹ Found ${existingTickets.size} existing tickets in sheet`);
        } else {
            Logger.log('ğŸ“‹ Sheet is empty (no existing tickets)');
        }

        // Prepare data rows
        Logger.log('ğŸ”„ Processing tickets...');
        const newRows = [];
        let skippedCount = 0;

        tickets.forEach((ticket, index) => {
            const ticketNumber = ticket['Ticket Number'];

            // Skip if already imported
            if (ticket.import_to_tracker) {
                Logger.log(`â­ï¸ Ticket ${index + 1}: ${ticketNumber} - Skipped (already marked as imported in DB)`);
                skippedCount++;
                return;
            }

            if (existingTickets.has(ticketNumber)) {
                Logger.log(`â­ï¸ Ticket ${index + 1}: ${ticketNumber} - Skipped (already exists in sheet)`);
                skippedCount++;
                return;
            }

            // Create row matching EU format: Ticket Number, Date, Time Start, Time End, Ticket Type, Reason Escalate, Work Status, Agent Name, Account
            const row = [
                ticket['Ticket Number'] || '',
                ticket['Date'] || '',
                ticket['Time Start'] || '',
                ticket['Time End'] || '',
                ticket['Ticket Type'] || '',
                ticket['Reason Escalate'] || '',
                ticket['Work Status'] || '',
                ticket['Agent Name'] || '',
                ticket['Account'] || ''
            ];

            Logger.log(`âœ… Ticket ${index + 1}: ${ticketNumber} - Will be imported`);
            newRows.push(row);
        });

        Logger.log(`ğŸ“Š Processing summary: ${newRows.length} new tickets, ${skippedCount} skipped`);

        let updated = 0;
        if (newRows.length > 0) {
            // Append new rows
            const startRow = lastRow + 1;
            Logger.log(`ğŸ“ Writing ${newRows.length} rows starting at row ${startRow}...`);
            sheet.getRange(startRow, 1, newRows.length, newRows[0].length).setValues(newRows);
            updated = newRows.length;

            Logger.log(`âœ… Successfully imported ${updated} new EU tickets`);
        } else {
            Logger.log('âš ï¸ No new tickets to import');
        }

        return {
            count: tickets.length,
            updated: updated
        };
    } catch (error) {
        Logger.log(`âŒ ERROR in importToEUSheet: ${error.toString()}`);
        Logger.log(`ğŸ“ Error stack: ${error.stack}`);
        throw error;
    }
}

// Import single ticket to EU sheet
function importSingleTicketToEUSheet(ticket) {
    Logger.log(`ğŸ“Š === IMPORTING SINGLE TICKET TO EU SHEET ===`);

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sheet = ss.getActiveSheet();
        Logger.log(`ğŸ“‚ Spreadsheet: ${ss.getName()}`);
        Logger.log(`ğŸ“„ Active sheet: ${sheet.getName()}`);

        const ticketNumber = ticket['Ticket Number'];
        Logger.log(`ğŸ« Processing ticket: ${ticketNumber}`);

        // Check if ticket already exists
        const lastRow = sheet.getLastRow();
        const existingTickets = new Set();

        if (lastRow >= DATA_START_ROW) {
            const existingData = sheet.getRange(DATA_START_ROW, 1, lastRow - DATA_START_ROW + 1, 1).getValues();
            existingData.forEach(row => {
                if (row[0]) existingTickets.add(row[0].toString());
            });
        }

        if (existingTickets.has(ticketNumber)) {
            Logger.log(`â­ï¸ Ticket ${ticketNumber} already exists in sheet, skipping`);
            return {
                success: true,
                message: `Ticket ${ticketNumber} already imported`,
                alreadyExists: true
            };
        }

        // Create row
        const row = [
            ticket['Ticket Number'] || '',
            ticket['Date'] || '',
            ticket['Time Start'] || '',
            ticket['Time End'] || '',
            ticket['Ticket Type'] || '',
            ticket['Reason Escalate'] || '',
            ticket['Work Status'] || '',
            ticket['Agent Name'] || '',
            ticket['Account'] || ''
        ];

        // Append to sheet
        const startRow = lastRow + 1;
        Logger.log(`ğŸ“ Writing ticket to row ${startRow}...`);
        sheet.getRange(startRow, 1, 1, row.length).setValues([row]);

        // Mark as imported in Supabase
        markEUTicketAsImported(ticket.id);

        Logger.log(`âœ… Successfully imported ticket ${ticketNumber}`);

        return {
            success: true,
            message: `Ticket ${ticketNumber} imported successfully`
        };

    } catch (error) {
        Logger.log(`âŒ ERROR importing single ticket: ${error.toString()}`);
        return {
            success: false,
            message: error.toString()
        };
    }
}

// Mark single EU ticket as imported
function markEUTicketAsImported(ticketId) {
    Logger.log(`ğŸ”„ Marking ticket ${ticketId} as imported in Supabase...`);

    const url = `${SUPABASE_URL}/rest/v1/tickets?id=eq.${ticketId}`;
    const options = {
        method: 'patch',
        headers: {
            'apikey': SUPABASE_KEY,
            'Authorization': `Bearer ${SUPABASE_KEY}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=minimal'
        },
        payload: JSON.stringify({
            import_to_tracker: true
        }),
        muteHttpExceptions: true
    };

    try {
        const response = UrlFetchApp.fetch(url, options);
        const responseCode = response.getResponseCode();

        if (responseCode === 204 || responseCode === 200) {
            Logger.log(`âœ… Ticket ${ticketId} marked as imported`);
        } else {
            Logger.log(`âš ï¸ Failed to mark ticket as imported. Status: ${responseCode}`);
        }
    } catch (error) {
        Logger.log(`âŒ Error marking ticket as imported: ${error.toString()}`);
    }
}

/********************** TEST FUNCTIONS **********************/
// Test 1: Check if we can fetch data from Supabase
function testFetchData() {
    Logger.log('ğŸ§ª === Testing Supabase Connection ===');
    try {
        const tickets = fetchEUTicketsFromSupabase();
        Logger.log(`âœ… SUCCESS: Fetched ${tickets.length} tickets`);

        if (tickets.length > 0) {
            Logger.log('ğŸ“ First ticket data:');
            Logger.log(JSON.stringify(tickets[0], null, 2));
        } else {
            Logger.log('âš ï¸ No tickets found. Check if:');
            Logger.log('   1. SQL view tickets_export_eu_v exists in Supabase');
            Logger.log('   2. There are EU team tickets with import_to_tracker=false');
            Logger.log('   3. Agent team column is set to "EU"');
            Logger.log('   4. Agents are assigned to tickets');
        }
    } catch (error) {
        Logger.log(`âŒ ERROR: ${error.toString()}`);
        Logger.log(`ğŸ“ Error stack: ${error.stack}`);
    }
}

// Test 2: Check sheet access
function testSheetAccess() {
    Logger.log('ğŸ§ª === Testing Sheet Access ===');
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        Logger.log(`âœ… Spreadsheet: "${ss.getName()}"`);
        Logger.log(`ğŸ“ Spreadsheet ID: ${ss.getId()}`);

        const sheets = ss.getSheets();
        Logger.log(`ğŸ“‹ Total sheets: ${sheets.length}`);
        Logger.log(`ğŸ“„ Available sheets: ${sheets.map(s => s.getName()).join(', ')}`);

        const sheet = ss.getActiveSheet();
        if (sheet) {
            Logger.log(`âœ… Active sheet: "${sheet.getName()}"`);
            Logger.log(`   Last row: ${sheet.getLastRow()}`);
            Logger.log(`   Last column: ${sheet.getLastColumn()}`);

            // Check if headers exist
            if (sheet.getLastRow() >= HEADER_ROW) {
                const headers = sheet.getRange(HEADER_ROW, 1, 1, sheet.getLastColumn()).getValues()[0];
                Logger.log(`   Headers: ${headers.join(', ')}`);
            } else {
                Logger.log(`   âš ï¸ No headers found - sheet appears empty`);
            }
        } else {
            Logger.log(`âŒ No active sheet found!`);
        }
    } catch (error) {
        Logger.log(`âŒ ERROR: ${error.toString()}`);
        Logger.log(`ğŸ“ Error stack: ${error.stack}`);
    }
}

// Test 3: Full import test
function testEUImport() {
    Logger.log('ğŸ§ª === Testing Full Import ===');
    try {
        const tickets = fetchEUTicketsFromSupabase();
        Logger.log(`ğŸ“Š Fetched ${tickets.length} tickets from Supabase`);

        if (tickets.length > 0) {
            Logger.log('ğŸ“ Sample ticket: ' + JSON.stringify(tickets[0], null, 2));
            const result = importToEUSheet(tickets);
            Logger.log(`âœ… Import result: ${JSON.stringify(result)}`);
            Logger.log(`   Total processed: ${result.count}`);
            Logger.log(`   New tickets added: ${result.updated}`);
        } else {
            Logger.log('âš ï¸ No tickets to import');
        }
    } catch (error) {
        Logger.log(`âŒ ERROR: ${error.toString()}`);
        Logger.log(`ğŸ“ Error stack: ${error.stack}`);
    }
}

// Test 4: Test complete flow (simulates doPost)
function testCompleteFlow() {
    Logger.log('ğŸ§ª === Testing Complete Flow (Simulating doPost) ===');
    try {
        Logger.log('Step 1: Fetch tickets from Supabase');
        const tickets = fetchEUTicketsFromSupabase();
        Logger.log(`âœ… Fetched ${tickets.length} tickets`);

        if (tickets.length === 0) {
            Logger.log('âš ï¸ No tickets to process - stopping test');
            return;
        }

        Logger.log('Step 2: Import to sheet');
        const result = importToEUSheet(tickets);
        Logger.log(`âœ… Import completed`);
        Logger.log(`   Result: ${JSON.stringify(result)}`);

        Logger.log('ğŸ‰ Complete flow test PASSED');
    } catch (error) {
        Logger.log(`âŒ Complete flow test FAILED: ${error.toString()}`);
        Logger.log(`ğŸ“ Error stack: ${error.stack}`);
    }
}

